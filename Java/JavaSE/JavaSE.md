# JavaSE学习笔记

## 目录：

[TOC]

## 1. 概述

### 1.1 Java的起源和特征

**Java 编程语言**最初是由**Sun公司**开发的，该公司由 **James gosling** 于 1995 年创立 。

随着 Java 的发展进步和它的广泛流行， Java 做出了很多调整从而适应不同类型的平台。例如： J2EE 是为企业级应用程序设计的， J2ME 是为移动应用程序设计的。 

Java的特征有：面向对象性，平台独立性，简单性，安全性，体系结构中立性，便捷性，稳健性，多线程，易于理解，高性能，分布式，动态性。

### 1.2 Java跨平台的原因

JVM（Java Virtual Machine）是Java语言实现跨平台的关键。

Java源代码首先会被编译成平台无关的字节码，而字节码可以交给不同平台的JVM去执行。

所以只能说Java是跨平台的，而JVM不是。

### 1.3 JDK环境变量

- Windows：
  1. Java_Home：新建变量`Java_Home`，内容为jdk的目录。
  2. Path：在`path`变量中增加`%JAVA_HOME\bin%`。
  3. classpath：新建变量`CLASSPATH`，内容为`.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar`。

- Linux：

  编辑`/etc/profile`文件，在末尾加入：

  ```
  export JAVA_HOME=(JDK安装目录)
  export JRE_HOME=${JAVA_HOME}/jre
  export CLASSPATH=.:${JAVA_HOME}/lib/tools.jar:${JRE_HOME}/lib/dt.jar
  export PATH=${JAVA_HOME}/bin:${JAVA_HOME}/jre/bin:$PATH
  ```

- 相关解释：

  1. JAVA_HOME指JDK的目录，很多需要JDK的程序会默认去取这个环境变量。
  2. 将JDK中的bin目录添加到Path环境变量，就可以在任意目录下执行bin中的可执行程序，例如`javac.exe`和`java.exe`。
  3. CLASSPATH的设置，可以使得在任意位置访问指定class文件。CLASSPATH中有多个项，系统将从左到右寻找class文件。



## 2. Java基础知识&语法

### 2.1 关键字与标识符

- 关键字：被Java语言赋予特定含义的单词，一些软件中会高亮显示。

  - Java的关键字有：

  ```
  abstract,assert,boolean,break,byte,case,catch,char,class,const（保留关键字）,continue,default,do,double,else,enum,extends,final,finally,float,for,goto（保留关键字）,if,implements,import,instanceof,int,interface,long,native,new,package,private,protected,public,return,short,static,strictfp,super,switch,synchronized,this,throws,transient,try,void,volatile,while
  ```

  - 常用关键字说明：

    - continue：

      只用在循环语句中，跳出单层循环中的一次，可以进行下一次。

    - break：

      只用在循环和switch语句中，作用为跳出循环。

      通过标签语句的配合可以跳出多层循环。

    - private：

      是一个权限修饰符，被修饰的成员（变量、方法）只能在本类中才能访问。

    - return：

      用于结束方法，一旦遇到return，程序就不再继续往后执行。

    - static：

      用于修饰成员变量和成员方法，表示该成员是静态的。

      static修饰的成员：

      1. 随着类的加载而加载
      2. 优先于对象存在
      3. 被类中所有对象共享
      4. 可以通过**类名**调用

  - 注意事项：

    1. 关键字为全部小写。
    2. 不能作为标识符名。

- 标识符：给类、接口、方法（函数）、变量等起名字的字符序列。

  - 组成规则：

    由大小写的英文字母、数字、`$`和`_`组成。

  - 命名规则：

    - 包：全部小写，例如`com.zxy`。
    - 类/接口：首字母大写，例如`Student`。
    - 方法（函数）/变量：首字母小写，后续单词首字母大写，例如`indexOfElement`。
    - 常量：全部大写，例如`STUDENT_MAX_AGE`。

  - 注意事项：

    1. 标识符不能是关键字。
    2. 不能以数字开头。
    3. 区分大小写。

### 2.2 注释

注释就是对程序进行解释说明的文字，能提高代码的可阅读性。

- 单行注释：

  ```
  // 注释内容
  ```

- 多行注释：

  ```
  /*
  	注释内容
  */
  ```

- 文档注释：

  ```java
  /**
  	这方法天下第一，非常的🐮🍺。
  	@author 作者
  	@version 版本
  	@param a 参数说明
  	@return b 返回值说明
  	@throws NullPointerException 可能抛出的异常说明
  */
  ```

### 2.3 常量&变量&进制

- 常量：程序执行过程中，其值不发生改变的量。

  具体分为如下几类：

  - 整数常量：`12`，`23`。
  - 小数常量：`12.345`。
  - 字符常量：`a`，`A`。
  - 字符串常量：`"Hello!"`。
  - 布尔常量：`true`，`false`。
  - 空常量：`null`。
  - 自定义常量：final修饰。

- 变量：程序执行过程中，其值在某个范围内可以发生改变的量。

  定义格式：

  ```
  数据类型 变量名 = 初始化值;
  数据类型 变量名;
  变量名 = 初始化值;
  ```

- 进制相关：

  - 二进制：以`0b`开头。
  - 八进制：以`0`开头。
  - 十进制：默认就是十进制。
  - 十六进制：以`0x`开头。

### 2.4 数据类型&转换

Java是强类型的语言，针对每种数据提供了对应的数据类型。

- 基本数据类型：

  分为如下八种：

  |  名称   |  占用字节  |                         备注                         |
  | :-----: | :--------: | :--------------------------------------------------: |
  |  byte   |     1      |       0000 0000 包含这8个bit（位），-128 ~ 127       |
  |  short  |     2      |                    -32768 ~ 32767                    |
  |   int   |     4      |               -2147483648 ~ 2147483647               |
  |  long   |     8      |                    -2^63 ~ 2^63-1                    |
  |  float  |     4      |         1bit符号位，8bit指数位，23bit尾数位          |
  | double  |     8      |         1bit符号位，11bit指数位，52bit尾数位         |
  |  char   |     2      |          由于默认采用Unicode编码，故为2字节          |
  | boolean | 1（未定4） | 实际占用字节数未明确规定，编译后可能转成int所以未定4 |

  注意事项：

  1. 关于float和double的具体精度：

     符号位、指数位和尾数位表示一个数的公式：`符号位 1.尾数位 * 2^指数位`，类似十进制科学计数法。

     吉祥物：`0b1.11111111111111111111111 x 10(2)^1000(8)`。

     **指数位决定了大小范围**，因为指数越大，能表示的数就越大。

     **尾数位（小数位）决定了精度**，因为后面的小数越多，精度越高。

     所以对于float，其有23bit小数位，2^23=8,388,608。其最多能有7位有效数字，但只有6位能保证绝对精确。

     同理对于float，其最多有16位有效数字，但只能保证15位绝对精确。

     **然而这些目前并没有卵用，精确计算小数用BigDecimal。**

  2. 关于char：

     占用字节数取决于编码，而Java语言采用Unicode作为默认编码，故默认char占用2字节。

  3. 关于boolean：

     Java并没有明确说明boolean占用多少个字节。

     一说具体取决于JVM，而部分JVM的boolean编译后会变成int。

     所以暂定有1或4个字节两种说法。

  4. 在定义long或者float类型变量的时候，要加L或f。

- 引用数据类型：

  Java有5种引用类型：类、接口、数组、枚举、标注。

- 基本数据类型的转换：

  - 整形和浮点型可以进行从小到大的转换，即：

    byte,short,char -> int -> long		float -> double

  - byte,short,char之间不相互转换，直接转成int参与运算。

  - 可以通过强制转换的方式将大的数据类型转换成小的，不过有可能损失精度，格式如下：

    ```
    目标数据类型 变量名 = (目标数据类型)被转换的数据;
    ```


### 2.5 运算符

Java中的运算符如下（优先级数字越小，越优先）：

|                            运算符                            |                 说明                 | 优先级 |
| :----------------------------------------------------------: | :----------------------------------: | :----: |
|                        `()` `[]` `.`                         |           括号（优先运算）           |   1    |
|                  `!` `+` `-` `~` `++` `--`                   |          非/正/负/自增/自减          |   2    |
|                         `*` `/` `%`                          |             乘/除/取余数             |   3    |
|                           `+` `-`                            |                加/减                 |   4    |
|                       `<<` `>>` `>>>`                        |              移位运算符              |   5    |
|                `<` `<=` `>` `>=` `instanceof`                | 小于/小于等于/大于/大于等于/类型判断 |   6    |
|                          `==` `!=`                           |             等于/不等于              |   7    |
|                             `&`                              |                按位与                |   8    |
|                             `^`                              |               按位异或               |   9    |
|                             `|`                              |                按位或                |   10   |
|                             `&&`                             |                逻辑与                |   11   |
|                             `||`                             |                逻辑或                |   12   |
|                        `xx ? xx : xx`                        |          条件（三元）运算符          |   13   |
| `=` `+=` `-=` `*=` `/=` `%=` `&=` `|=` `^=` `~=` `<<=` `>>=` `>>>=` |              赋值运算符              |   14   |

**重要说明：**

1. `+`有三种用法：

   - 加法
   - 正号，此时优先级高于加减乘除等，负号同理
   - 字符串连接符。注意**字符串连接符**在编译后会将前面的字符串包装成**StringBuilder**，并与后面的字符串作**append**操作。这意味着若在**循环中使用**字符串连接符，会不停地造StringBuilder对象。建议的方式为在循环之前造好StringBuilder对象。

2. `+=`等运算符包含了**强制类型转换**，举例如下：

   ```java
   short s = 1;
   s += 1;			//编译通过，因为相当于s = (s的类型)s+1
   s = s + 1;		//报错，因为1默认是int类型，运算后返回一个int
   ```

3. `++`和`--`运算符：

   - 若放在操作数后，会先以操作数原数参与运算，再自增/自减操作数，举例：

     ```java
     int x = 1,y = 1;
     y = 1 + x++;		//x = 2, y = 2
     ```

   - 若放在操作数前，会先自增/自减操作数，再参与运算，举例：

     ```java
     int x = 1,y = 1;
     y = 1 + ++x;		//x = 2, y = 3
     ```

4. `&&`和`||`，与`&`和`|`的不同在于：

   一旦`&&`左边的值为false，则**不会继续判断右边的**了，直接返回false。

   同理一旦`||`左边的为true，则直接返回true。

5. `<<`、`>>`和`>>>`位运算符（不常用）：

   - `<<`左移：

     格式：

     ​	操作数<<左移位数

     说明：

     ​	将操作数的二进制按照位数向左移动，左边越界的部分舍弃，右边补0。

     ​	相当于`操作数x2^左移位数`。

     举例：

     ```java
     3<<2;	//12, 相当于3x2^2, 00000011左移两位后变成00001100
     ```

   - `>>`右移：

     格式：

     ​	操作数>>右移位数

     说明：

     ​	将操作数的二进制按照位数向右移动，右边越界的部分舍弃，最左边一位保留原符号位。

     ​	相当于`操作数/2^右移位数`。

     举例：

     ```java
     6>>2;	//1, 相当于6/2^2, 符号位的0保留, 00000110右移两位后变成00000001
     ```

   - `>>>`无符号右移：

     说明：

     ​	无符号右移与右移的区别在于，无符号右移符号位始终补0。

6. `&`、`|`和`^`等作为按位运算符时：

   将两个数对应bit上的二进制数进行对比运算，返回新的数。

   例如：

   ```java
   6 & 3;	//2, 00000110 & 00000011 得 00000010
   ```

### 2.6 原码/反码/补码

概述：

​	原码/反码/补码是数据在计算机中的三种表示形式。

​	计算机在操作的时候，一般都是采用数据对应的二进制**补码**来进行计算的。

说明：

- 原码：

  **最高位为符号位**，0为正，1为负。

  后面的都是数值位，在原码中，数值位直接就是数据的二进制表示。

  例如：

  ​	-7的原码：`10000111`。

- 反码：

  正数的反码**与原码相同**。

  负数的反码**符号位不变**，数值位**全部取反**。

  例如：

  ​	-7的反码：`11111000`。

- 补码：

  正数的补码**与原码相同**。

  负数的补码，在**反码的基础上加1**。

  例如：

  ​	-7的补码：`11111001`。

要点：

1. 正数的原码、反码和补码都**相同**。
2. 负数的原码、反码和补码的**符号位都为1**。
3. 负数反码的**数值位**在原码的基础上**取反**，补码又在反码的基础上**加1**。

### 2.7 流程控制语句

流程控制语句用于控制程序执行的流程，以实现各种结构方式。

- 选择语句：

  - switch：

    格式：

    ```java
    switch(表达式：byte/short/int/char/Enum(JDK5)/String(JDK7)){
        case 值1:
            语句...;
            break;
        case 值2:
            语句...;
            break;
        ...
        default:
            语句(没有以上项时执行)...;
            break;
    }
    ```

    注意事项：

    1. case后面只能是**常量**。
    2. default可以省略。
    3. break不建议省略，若case后的break省略了，系统会**顺延执行后面case中的语句**。

- 判断语句：

  - if：

    格式：

    ```java
    if(表达式，返回值必须为true或false){
        语句...;
    }else if{
        语句...;
    }else if{
        语句...;
    }
    ...
    else{
        语句...;
    }
    ```

    注意事项：

    1. if控制的语句若为一句，可省略大括号。
    2. `else if{...}`和`else{...}`可以没有。
    3. 表达式的返回值必须是true或false。

- 循环语句：

  - while：

    格式1：

    ```java
    while(判断条件语句){
        循环体语句;
        ...
    }
    ```

    格式2：

    ```java
    do{
        循环体语句;
        ...
    }while(判断条件语句)
    ```

  - for：

    格式：

    ```java
    for(初始化语句;判断条件语句;控制条件语句){
        循环体语句;
        ...
    }
    ```


  注意事项：

  1. 注意循环的控制条件，避免死循环。
  2. 循环体语句如果是一条，可以省略大括号。

### 2.8 方法（函数）

概述：

​	方法是完成特定功能的代码块，在很多语言中被称为函数。

定义格式：

```
修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数名2, ...){
    方法体语句;
    return 返回值;
}
```

相关名词：

- 方法重载：

  在同一个类中，存在**方法名相同**，而**参数列表不同**（参数类型和个数）的多个方法。

  与返回值无关。

注意事项：

1. 方法不调用就不会执行。
2. 方法之间是平级关系，不能嵌套定义。
3. 方法定义的时候，参数是用`,`隔开的。
4. 方法在调用的时候，不用再传递数据类型。
5. 如果方法有明确的返回值类型，就必须有return返回语句。

### 2.9 Java内存分配

Java内存分配包含如下几个部分：

- 栈
- 堆
- 方法区
- 本地方法区
- 寄存器



## 3. 面向对象

### 3.1 面向对象的概述

面向对象，是一种编程思想。相对于面向过程，有如下好处：

- 更接近人的思考习惯
- 把复杂的事情简单化
- 让我们从执行者变成了指挥者

### 3.2 类&对象

Java语言最基本的单位是类，类是一组相关的属性和行为的集合。

### 3.3 抽象类&接口

- 抽象类：

  一个不是具体的功能称为抽象功能，一个类中若存在抽象功能，则该类必是抽象类。

  **抽象类的特点：**

  1. 抽象类和抽象方法必须用abstract关键字修饰
  2. 抽象类中不一定有抽象方法，但是有抽象方法的类必然是抽象类
  3. 抽象类有构造方法，但是不能实例化
  4. 抽象类的子类可以是抽象类或具体类，若要有一个具体子类，该类需重写所有抽象方法

  **抽象类的成员特点：**

  - 成员变量：既可以是变量，也可以是常量
  - 构造方法：有，用于子类访问父类数据的初始化
  - 成员方法：既可以是抽象的，也可以是非抽象的

  **定义格式：**

  ```java
  abstract class{...}			//定义抽象类
  public abstract void function{...}		//定义抽象方法
  ```

  **抽象类的注意事项：**

  1. 一个类如果没有抽象方法，也可以定义为抽象类，意义是不让创建对象。
  2. abstract不能和以下关键字共存：
     - private：共存时报非法的修饰组合，原因是private方法不能被重写，而abstract修饰的方法必须让子类重写。
     - final：共存时报非法的修饰组合，理由同上。
     - static：共存时不报错但是无意义，因为被static修饰的方法可以通过类名直接调用，而抽象方法没有方法体。

- 接口：

  **接口的特点：**

  1. 接口用关键字interface表示：

  ```java
  interface 接口名 {}
  ```

  2. 类实现接口用implements表示

  ```java
  class 类名 implements 接口名 {}
  ```

  3. 接口不可以实例化，不过可以通过多态的方式来实例化
  4. 接口的子类：
     - 可以是抽象类，不过意义不大；
     - 可以是具体类，不过要求子类重写接口中所有的抽象方法。

  **接口成员特点：**

  1. 成员变量：接口的成员变量只能是常量，并且是静态的。

  		默认修饰符：public static final   建议这三个修饰符手动给出。

  2. 构造方法：接口没有构造方法，实现接口的类是继承的Object类的构造方法。

  		（类Object是类层次结构的根类，每个类都使用Object作为超类）

  3. 成员方法：接口的成员方法只能是抽象方法，

  		默认修饰符：public abstract    建议这两个修饰符手动给出。

  **接口、类之间的关系：**

  1. 类与类：

  		继承关系，可以是单继承，也可以是多层继承，**不可以多继承**。

  2. 类与接口：

  		实现关系，可以单实现，也可以多实现，并且还可以在继承一个类的同时实现多个接口。
  	格式举例：

  ```java
  class son extends Object implements Father,Mother
  ```

  3. 接口与接口：

  		继承关系，可以单继承，也可以多继承
  	格式举例：

  ```java
  interface Sister extends Father,Mother
  ```

### 3.4 封装&继承&多态

封装继承多态是Java语言的三大特性。

- 封装：

  隐藏对象的属性和实现细节，仅对外公开访问方法。

  **目的：**

  1. 增强安全性；
  2. 简化编程。

  **基本要求：**

  1. 把所有属性私有化；
  2. 对每个属性提供get和set方法。

- 继承：

  在一个现有类的基础上，增加新的功能/重写已有方法。

  继承更多的是体现`is a`的关系。

  **继承的优点：**

  1. 提高代码的复用性。
  2. 增量式开发模式，提高开发效率。
  3. 避免修改原代码带来的风险。

  **继承中的约束：**

  1. 父类中private修饰的成员不能被继承。
  2. 不能继承父类的构造方法，不过可以使用`super()`来初始化。
  3. Java中只能**单继承**（类或抽象类），不能多继承。
  4. 类/抽象类/接口可以继承**任意多个**接口。

- 多态：

  相同的事务，掉用相同的方法时，表现出不同的行为。

  **实现多态的三个必要条件：**

  1. 继承：多态中必须要存在有继承关系的父类和子类；
  2. 重写：子类重新定义父类中某些方法；
  3. 向上转型：将子类引用赋值给父类对象。



## 4. 常用类

### 4.1 Scanner

- **概述：**

  用来实现键盘录入的类。

- **构造方法：**

  `Scanner(InputStream source)`						//new Scanner(System.in)

- **重要方法：**

  | public boolean hasNextXxx() | 判断是否是某种类型的元素 |
  | --------------------------- | ------------------------ |
  | public Xxx nextXxx()        | 获取该元素               |

- **注意事项：**

  1. public String nextLine()会扫描剩下的所有字符，直到遇到换行符"\n"为止。

     其行为不同于next()方法，该方法会从遇到的第一个有效字符（非空格、换行符）开始扫描，直到遇到空格或者换行符为止。

     这意味着如果在敲了enter后调用了nextLine()方法，nextLine()会立即扫描结束，并返回一个空值。然后继续执行后面的语句。

### 4.2 String

- **概述：**

  字符串就是由多个字符组成的一串数据，也可以看成是一个字符数组。

  通过查看API可知：

  1. 字符串字面值"abc"也可以看成是一个字符串对象；
  2. 字符串为常量，赋值后不能改变（是值不能改变，引用可以改变）。

- **构造方法：**

  | public String()                                  | 空构造                                                      |
  | ------------------------------------------------ | ----------------------------------------------------------- |
  | public String(byte[] bytes)                      | 把字节数组转成字符串                                        |
  | public String(byte[] bytes,int index,int length) | 把字节数组的一部分转换成字符串，从index开始，共length个成员 |
  | public String(byte[] bys, String charsetName)    | 通过指定字符集（编码表）解码给定字节数组，创建字符串对象    |
  | public String(char[] value)                      | 把字符数组转成字符串                                        |
  | public String(char[] value,int index,int length) | 把字符数组的一部分转成字符串，从index开始，共length个成员   |
  | public String(String original)                   | 把字符串常量值转成字符串                                    |

- **重要方法：**

  - 判断：

    | boolean equals(String str)           | 比较字符串的 [内容] 是否相同，区分大小写 |
    | ------------------------------------ | ---------------------------------------- |
    | boolean equalsIgnoreCase(String str) | 比较字符串的内容是否相同，不区分大小写   |
    | boolean contains(String str)         | 判断大字符串中是否包含小字符串           |
    | boolean startsWith(String str)       | 判断字符串是否以某个指定的字符串开头     |
    | boolean endsWith(String str)         | 判断字符串是否以某个指定的字符串结尾     |
    | boolean isEmpty()                    | 判断字符串是否为空                       |

  - 获取长度&索引：

    | int length()                          | 获取字符串的长度                                             |
    | ------------------------------------- | ------------------------------------------------------------ |
    | char charAt(int index)                | 获取指定索引位置的字符                                       |
    | int indexOf(int ch)                   | 返回指定字符在此字符串中第一次出现的索引                     |
    | int indexOf(String str)               | 返回指定字符串在此字符串中第一次出现的索引，返回的是首字符的索引 |
    | int indexOf(int ch,int fromIndex)     | 返回指定字符在此字符串中从指定位置后第一次出现的索引         |
    | int indexOf(String str,int fromIndex) | 返回指定字符串在此字符串中从指定位置后第一次出现的索引       |

  - 截取：

    | String substring(int beginIndex)              | 从beginIndex开始一直到结尾截取新的字符串并返回 |
    | --------------------------------------------- | ---------------------------------------------- |
    | String substring(int beginIndex,int endIndex) | 从beginIndex开始到endIndex截取新的字符串并返回 |

  - 与其他数据类型转换：

    | byte[] getBytes()                   | 把字符串转换为Byte（字节）数组                 |
    | ----------------------------------- | ---------------------------------------------- |
    | byte[] getBytes(String charsetName) | 使用给定字符集（编码表）将字符串编码为字节数组 |
    | char[] toCharArray()                | 把字符串转换为字符数组                         |
    | static String valueOf(char[] chs)   | 把字符数组转换成字符串                         |
    | static String valueOf(int i)        | 把int类型数据转成字符串                        |

  - 大小写转换、拼接、替换：

    | String toLowerCase()                  | 把字符串转成小写                                             |
    | ------------------------------------- | ------------------------------------------------------------ |
    | String toUpperCase()                  | 把字符串转成大写                                             |
    | String concat(String str)             | 把字符串拼接                                                 |
    | String replace(char old,char new)     | 把字符串中所有old字符替换为new字符                           |
    | String replace(String old,String new) | 把字符串中所有old小字符串替换成new小字符串，返回替换后的字符串，原有字符串不发生改变 |

  - 去除空格&比较：

    | String trim()                       | 去除字符串两端的空格         |
    | ----------------------------------- | ---------------------------- |
    | int compareTo(String str)           | 按字典顺序比较，区分大小写   |
    | int compareToIgnoreCase(String str) | 按字典顺序比较，不区分大小写 |

    字符串比较的说明：

    ​	比较字符串与参数字符串第一个字符，若不等，返回字符串ASCII-参数字符串ASCII；若相等，比较下一位；以此类推。

    ​	若两个字符串不同，且一个字符串为另一个字符串的前面N位，返回字符串长度。

### 4.3 StringBuffer/StringBuilder

- **概述：**

  StringBuffer是可变字符串，数据同步、安全，效率低。

  StringBuilder是不同步，线程不安全，但是速度更快的可变字符串。

- **StringBuffer和String的区别：**

  StringBuffer长度可变，而String长度不可变。

  用StringBuffer做字符串拼接，不会浪费太多系统资源。

- **构造方法：**

  | public StringBuffer()             | 无参构造方法                     |
  | --------------------------------- | -------------------------------- |
  | public StringBuffer(int capacity) | 指定容量的字符串缓冲区对象       |
  | public StringBuffer(String str)   | 指定字符串内容的字符串缓冲区对象 |

- **重要方法：**

  - 获取容量&长度：

    | public int capacity() | 返回当前容量       |
    | --------------------- | ------------------ |
    | public int length()   | 返回长度（字符数） |

  - 拼接&插入：

    | public StringBuffer append(String str)            | 把任意类型数据添加到字符串缓冲区后面，返回字符串缓冲区本身 |
    | ------------------------------------------------- | ---------------------------------------------------------- |
    | public StringBuffer insert(int offset,String str) | 在指定位置把任意类型数据添加到字符串缓冲区里面             |

  - 删除部分内容：

    | public StringBuffer deleteCharAt(int index)   | 删除指定位置的字符，并返回本身                               |
    | --------------------------------------------- | ------------------------------------------------------------ |
    | public StringBuffer delete(int start,int end) | 删除指定位置开始到指定位置结束的字符，并返回本身，包左不包右 |

  - 替换部分内容：

    public StringBuffer replace(int start,int end,String str)

    从Start开始到End用str替换，包左不包右

  - 反转：

    public StringBuffer reverse()

    将字符串反转

  - 截取：

    | public String subString(int start)         | 从start到结尾/到end截取字符串，包左不包右          |
    | ------------------------------------------ | -------------------------------------------------- |
    | public String substring(int start,int end) | 注意返回值为String，方法不对StringBuffer本身做修改 |

- **StringBuffer/StringBuilder和String相互转换：**

  - String => StringBuffer

    1. 通过构造方法public StringBuffer(String str)

       ```java
       StringBuffer sb = new StringBuffer(str);
       ```

    2. 通过append()方法public StringBuffer append(String str)

       ```java
       sb.append(s);
       ```

  - StringBuffer => String

    1. 通过构造方法public String(StringBuffer buffer)

       ```java
       String str = new String(buffer);
       ```

    2. 通过toString()方法public String toString()

       ```java
       String str = buffer.toString();
       ```

### 4.4 Arrays

- **概述：**

  Arrays是操作数组的工具类，提供静态方法。

- **重要方法：**

  | public static String toString(int[] arr)          | 把数组转成字符串"[11, 22, 33]"                               |
  | ------------------------------------------------- | ------------------------------------------------------------ |
  | public static void sort(int[] arr)                | 对数组进行升序排序                                           |
  | public static int binarySearch(int[] arr,int key) | 二分查找key在arr中的位置，注意在查找前需对数组进行排序（sort） |
  | public static <T> List<T> asList(T... a)          | 把数组转成集合，这里转成的是Arrays私有的特殊ArrayList，不包含add和remove等方法，长度不变 |

### 4.5 Integer

- **概述：**

  



## 5. 通用知识

### 5.1 排序&查找

- **排序：**

  - 冒泡排序（bubbleSort）：

  相邻元素两两比较，大的往后放。

  第一次执行完毕，最大值出现在最大索引处。

  所以要循环执行`n-1`次。

  - 选择排序：

  从0索引开始，依次和后面的元素比较，小的往前放。

  第一次完毕，最小值出现在最小索引处。

- **查找：**

  - 二分查找：

    在数组元素有序的前提下，通过先查询中间数来判断目标数取值范围的方式，达到减少计算量的目的。

    要求首先对数组进行排序。



## 6. 数组

### 6.1 概述

数组是存储**同一种数据类型多个元素**的容器。

数组的每一个元素都有编号，称为**索引**（index），从0开始。

### 6.2 定义数组&初始化

**定义数组格式：**

```
数据类型[] 数组名;		//推荐方式
数据类型 数组名[];
```

**数组的初始化：**

- 动态初始化（只给长度，系统给出默认值）：

  ```
  int[] arr = new int[3];
  ```

- 静态初始化（给出各个值，系统决定长度）：

  ```
  int[] arr = new int[]{1,2,3};
  int[] arr = new int{1,2,3};			//简化写法
  ```

**遍历数组：**

​	使用for循环即可，举例：

```java
for(int x = 0;x < arr.length;x ++){
    arr[x]...;
}
```

### 6.3 二维数组

二维数组是元素类型为一维数组的数组。

​	定义格式：

```
int[][] arr = new int[外层数组长度][里层数组长度];	//动态初始化
int[][] arr = new int[外层数组长度][];			//可以暂不指定里层数组长度
int[][] arr = new int[][]{{...},{...},...};		//静态初始化
int[][] arr = {{...},{...},...};				//简化的写法
```

遍历二维数组，用循环嵌套即可。

### 6.4 注意事项

1. 数组一旦初始化完毕，其长度不再发生改变。



## 7. 集合框架



## 8. 异常



## 9. IO流



## 10. 多线程



## 11. 设计模式



## 12. 网络编程



## 13. 反射



