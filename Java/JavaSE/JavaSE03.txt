Java笔记03（Day19-Day27）

目录
	1.异常
	2.throw关键字
	3.Throwable类重要方法
	4.finally关键字
	5.自定义异常
	6.异常中涉及到继承的注意事项
	7.File类

1.异常
	概述：
		程序出现了不正常的情况。
	Java异常体系概述：
		类Throwable：程序的异常
			类Error：严重问题。不做处理，因为一般是难以/无法处理的问题，比如内存溢出。
			类Exception：异常。
				类RuntimeException：运行时异常。不做处理，因为此种异常问题在于代码不够严谨，需要修正代码。
				除RuntimeException以外Exception：编译期异常。必须进行处理，否则代码不能通过编译。
	异常的处理：
		1）默认处理：
				如果程序出现问题，并没有做任何处理，Jvm最终会做出默认处理。
				默认处理方式：
					把异常的名称、原因，及出现异常的位置输出在控制台，并结束程序。
		2）手动处理方式一：																可简化为：												可以出现多个catch：
				try {																				try {															try {
					...(可能会出现问题的代码)												...																...
				} catch (异常类名 变量名) {												} catch (异常类名 变量名) {							} catch (异常类名 变量名) {
					...(出现异常后的处理)														...																...
				} finally {																		}																} catch (异常类名 变量名) {
					...																																					...
				}																																					}
				原理：
					在try里面发现问题后，jvm会生成一个异常对象，然后把这个对象抛出，和catch中的类进行匹配。
					如果该对象是某个类型的，就会执行该catch里的处理信息。
				注意事项：
					A.能明确的尽量明确，不要用大的异常类名来处理；
					B.一旦try中出现了匹配的异常，就会执行对应的处理，并结束try...catch执行后面的代码;
					C.平级关系的异常谁先catch无所谓，如果出现了父子关系的异常，父异常必须在后面。
			手动处理方式二（JDK7新的处理方式）：
				try {
					...(可能出现问题的代码)
				} catch (异常名1 | 异常名2 | ... 变量) {
					...(处理)
				}
				注意事项：
					A.该方法不管是哪种异常，处理方式都是一致的；
					B.多个异常间必须是同级关系。
		3）抛出：
				有些时候我们没有权限处理/处理不了/不想处理，就不处理了。为了解决此时的出错问题，提供了抛出解决方案。
				格式：
					修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2,... { }
					注意throws跟在括号后面。
					throws后面可跟多个异常类名，用逗号隔开。
				说明：
					方法抛出了异常，将交给调用者处理。
					编译期异常抛出，调用者必须处理（否则报错）；运行期异常抛出，调用者可以不处理。
					尽量不要在main方法上抛出异常。
	异常处理方式的选择：
		1）如果该功能内部可以将问题处理，用try；如果处理不了，就交给调用者处理，用throws；
		2）后续程序如果需要继续运行就用try；不用继续运行就用throws。

2.throw关键字
	概述：
		如果出现了异常情况，我们可以手动把异常抛出（生成一个异常对象）。
		此关键字后面应该跟一个异常对象（throw new Exception()）。
	throw和throws的区别：
		throws																									throw
			1）用在方法声明后面，后跟异常类名；													1）用在方法体内，后跟异常对象；
			2）可以跟多个异常类名，用逗号隔开；													2）只能抛出一个异常对象；
			3）表示抛出异常，由该方法的调用者来处理；											3）表示抛出异常，由方法体内的语句处理；
			4）throws表示可能出现异常，可能不会出现。											4）throw表示抛出了异常，执行throw一定抛出了某种异常。

3.Throwable类重要方法：
	public String getMessage()																		//e.getMessage()，返回异常消息的字符串
	public String toString()																				//e.toString()，返回异常信息的简单描述，按照如下的格式：
		此对象的全路径完整类名	+ ": "(冒号+空格) + 调用此对象getLocalizedMessage()方法的结果（默认返回的是getMessage()的结果）
	void printStackTrace()																				//e.printStackTrace()，获取异常类名和异常信息，以及异常在程序中的位置，把结果输出在控制台

4.finally关键字
	概述：
		位于try {...} catch (...) {...} finally {...}之中。
		被finally控制的语句体一定会执行。
		存在例外：在执行finally之前jvm推出了，将不会执行finally中的语句。比如System.exit(0)。
	作用：
		用于释放资源，在io流操作和数据库操作中会见到。
	相关重要问题：
		1）final、finally、finalize的区别？
			final：是用于修饰类名、成员变量、成员方法的修饰符。
				final修饰类，该类不能被继承；
				final修饰成员变量，该变量为常量不能重新赋值；
				final修饰成员方法，该方法不能被重写。
			finally：是异常处理的一部分，用于释放资源。
				一般来说finally中的语句一定会执行，不过如果在finally之前退出了虚拟机，就不会执行。
			finalize：是Object中的一个方法，用于垃圾回收。
		2）如果catch里面有return语句，finally中的语句还会执行吗？
			会，并且会在return之前执行。
			准确来说，走到return语句时会生成一个返回路径，然后接着走finally中的代码，finally走完后再回到返回路径。
			举例：
				catch (Exception e) {
					a = 30;
					return a;
				} finally {
					a = 40;
				}									//将返回30
				
5.自定义异常
	概述：
		Java不可能所有异常都考虑到（比如需要分数在0-100之间），所以在实际开发中，可能需要自己定义异常。
		若要让一个类成为异常类，必须继承自Exception类或者RuntimeException类。
	注意事项：
		1）自定义的异常类不用写任何成员方法；
		2）可以通过写一个构造方法传一个字符串参数覆盖Exception类的构造方法，实现错误信息的输出，举例如下：
			class MyException extends Exception {
				public MyException () {}
				public MyException (String message) {
					super(message);
				}
			}										//只需要throw new MyException("错误信息")即可
		3）如果自定义的异常继承自Exception，则为编译期异常；继承自RuntimeException，则为运行期异常。
		
6.异常中涉及到继承的注意事项：
	1）子类重写父类方法时，子方法不能抛出比父方法级别更大的异常；
	2）如果父方法抛出了多个异常，子方法不能抛出比父方法更多的异常，也不能抛出父方法没有抛出的异常；
	3）如果父方法没有抛出异常，子方法不能抛出异常，只能try...catch，不能throws。
	
7.File类
	概述：
		要想实现IO的操作，就需要知道硬盘上文件的表现形式，Java提供了一个File类供我们使用。
		File类是文件和目录的抽象表现形式。
	重要构造方法：
		File(String pathname)																			//根据一个路径得到File对象<目录/文件>
		File(String parent, String child)																//根据parent<目录>和child<目录/文件>得到File对象
		File(File parent, String child)																	//根据一个父File对象<目录>和一个子文件/目录得到File对象
	重要方法：
		创建功能：
			public boolean createNewFile()															//file1.createNewFile()，创建文件。如果存在这样的文件就不创建了，并返回false。
			public boolean mkdir()																		//file1.mkdir()，创建文件夹。如果存在这样的文件夹就不创建了，并返回false。
			public boolean mkdirs()																	//file1.mkdirs()，创建文件夹。如果父文件夹不存在，会自动创建。
		删除功能：
			public boolean delete()																		//file1.delete()，删除文件或文件夹，如果没有删除返回false。
		重命名功能：
			public boolean renameTo(File dest)													//file1.renameTo(file2)，如果路径名相同就是改名，如果路径名不同则为改名+剪切粘贴。
		判断功能：
			public boolean isDirectory()																//file1.isDirectory()，判断是否为目录
			public boolean isFile()																		//file1.isDirectory()，判断是否为文件
			public boolean exists()																		//file1.exists()，判断是否存在
			public boolean canRead()																	//file1.canRead()，判断是否可读
			public boolean canWrite()																	//file1.canWrite()，判断是否可写
			public boolean isHidden()																	//file1.isHidden()，判断是否隐藏
		获取功能：
			public String getAbsolutePath()														//file1.getAbsolutePath()，获取绝对路径
			public String getPath()																		//file1.getPath()，获取路径
			public String getName()																	//file1.getName()，获取名称
			public long length()																			//file1.length()，获取长度（字节数）
			public long lastModified()																	//file1.lastModified()，获取最后一次修改时间（毫秒值）
			public String[] list()																			//file1.list()，获取指定目录下所有文件/文件夹的名称数组
			public String[] list(FilenameFilter filter)												//file1.list(filter)，根据一个文件名称过滤器的实现类对象，获取指定目录下满足要求的所有文件/文件夹的名称数组
			public File[] listFiles()																			//file1.listFiles()，获取指定目录下所有文件/文件夹的File数组
			public File[] listFiles(FilenameFilter filter)											//file1.listFiles(filter)，根据一个文件名称过滤器的实现类对象，获取指定目录下满足要求的所有文件/文件夹的File数组
	接口FilenameFilter概述：
		文件名称过滤器，包含一个方法boolean accept(File dir, String name)。
		dir为被找到的文件所在目录，name为文件的名称。
		文件满足要求时返回true，否则返回false。
		通常以匿名内部类的方式实现。
	注意事项：
		1）创建文件或者文件夹时，如果没有写盘符路径，会创建在默认路径下；
		2）删除功能中，如果要删除一个文件夹 ，该文件夹内不能包含文件或文件夹；
		3）Windows系统下，Java的删除不会走系统回收站；
		4）如果File的路径以盘符开始，则为绝对路径，否则为相对路径
		
8.递归
	概述：
		方法定义中调用方法本身的现象。
		举例：public void method () {
					method();
				}
		递归方法需要：规律和出口条件。
	注意事项：
		1）递归一定要有出口，否则就是死递归；
		2）递归次数不能太多，否则会不断加载方法到栈内存导致内存溢出；
		3）构造方法不能递归使用。
		
9.IO流
	概述：
		IO流用来处理设备间的数据传输（上传文件和下载文件）。
		Java对数据的操作是通过流的方式，用于操作流的对象都在IO包中。
	分类：
		按流向分：
			输入流（读取数据）
			输出流（写出数据）
		按数据类型分：
			字节流：
				用记事本打开文件，如果不能读懂，就用字节流。
				如果什么都不知道，就用字节流。
			字符流
				用记事本打开文件，如果可以读懂，就用字符流。
		所有分类：
			字节输入流：InputStream
			字节输出流：OutputStream
			字符输入流：Reader
			字符输出流：Writer
			以上基类都是抽象类，需要具体实现。
			每种基类的子类都以父类名结尾，如：
			
10.FileOutputStream文件字节输出流
	概述：
		用于将数据写入File的文件字节输出流。
	构造方法：
		FileOutputStream(File file)																	//创建一个向给定File所表示的文件中写入数据的文件字节输出流，从内容开头写入（如果文件存在会先删除所有原有内容）
		FileOutputStream(File file, boolean append)											//创建一个向给定File所表示的文件中写入数据的文件字节输出流，如果第二参数为true，从内容末尾写入
		FileOutputStream(String name)																//会根据给定String造一个File，并创建指向该File的fos对象，从内容开头写入（如果文件存在会先删除所有原有内容）
		FileOutputStream(String name, boolean append)									//会根据给定String造一个File，并创建指向该File的fos对象，如果第二参数为true，从内容末尾写入
	重要方法：
		public void write(int b)																			//fos.write(int)，输入一个ASCII数字表示的字节
		public void write(byte[] b)																		//fos.write(byte[])，输入一个字节数组的所有字节
		public void write(byte[] b, int off, int len)												//fos.write(byte[],起始索引,长度)，从一个字节数组的off开始，输入len个字节
	重要问题：
		创建字节输出流到底做了哪些事情？
			a.调用系统功能创建文件；
			b.创建fos对象；
			c.把fos对象指向这个文件。
		数据写成功后，为何要close()？
			a.把fos对象变成垃圾，这样就可以被系统回收了；
			b.通知系统回收跟该文件相关的资源。
		如何实现数据的换行？
			写入换行符号即可。
			一般来说，换行符号是"\n"，然而不同操作系统对换行符号的识别不同，Windows自带记事本可以识别的换行符号为"\r\n"。
			一些常见的高级记事本，是可以识别任意换行符号的。
		如何实现数据的追加写入？
			使用带有第二参数boolean append的构造方法即可，append为true。
			
11.FileInputStream文件字节输入流
	概述：
		从文件系统的某个文件中获得输入字节。
	构造方法：
		FileInputStream(File file)																		//从File表示的文件创建文件字节输入流
		FileInputStream(String name)																//从String表示的文件创建文件字节输入流
	重要方法：
		int read()																								//fis.read()，读取下一个字节，返回该字节的int表示。读完后指针会移动到已读字节后方，读完了还read()则会返回-1。
		int read(byte[] bys)																				//fis.read(byte[])，一次读取一个字节数组，返回实际读取到的字节个数
		
12.缓冲区类
	概述：
		测试发现一次读取一个数组的方式比一次读取一个字节的方式要快上很多，所以Java提供了带缓冲区的字节类（为了高效）。
		构造方法需要传一个基本的输入/输出流对象。
	构造方法：
		BufferedInputStream(InputStream in)													//创建具有默认缓冲区大小的缓冲区输入流
		BufferedOutputStream(OutputStream out)											//创建具有默认缓冲区大小的缓冲区输出流
		BufferedInputStream(InputStream in, int size)										//创建具有指定缓冲区大小的缓冲区输入流
		BufferedOutputStream(OutputStream out, int size)								//创建具有指定缓冲区大小的缓冲区输出流
		//一般不用指定缓冲区大小，默认就够用了
		
13.编码表
	概述：
		由现实世界的字符和对应的数值组成的一张表。
	常见编码表：
		ASCII码表：最高位为符号位，其余位为数值位。
		ISO-8859-1：拉丁码表，八位表示一个数据。
		GB2312：中国的中文码表。
		GBK：中国的中文码表升级，融合了更多的中文文字符号。
		GB18030：GBK的取代版本。
		BIG-5码：通行于台湾、香港等地的一个繁体字编码方案，俗称大五码。
		Unicode：国际标准码，融合了多种文字。所有文字都用两个字节来表示，Java语言用的就是Unicode。
		UTF-8：最多用三个字节来表示一个字符。
	String类相关方法：
		String(byte[] bys, String charsetName)													//通过指定字符集（编码表）解码给定字节数组，创建字符串对象
		byte[] getBytes(String charsetName)														//s.getBytes(编码表名)，使用给定字符集（编码表）将字符串编码为字节数组
		
14.字符流OutputStreamWriter/InputStreamReader
	重要构造方法：
		OutputStreamWriter(OutputStream out)												//根据默认编码把字节流的数据转换为字符流
		OutputStreamWriter(OutputStream out, String charsetName)				//根据给定编码把字节流的数据转换为字符流
		InputStreamReader(InputStream in)														//根据默认编码读取数据
		InputStreamReader(InputStream in, String charsetName)						//根据指定编码读取数据
	OutputStreamWriter的重要方法：
		public void write(int c)																			//osw.write(int)，写一个字符
		public void write(char[] cbuf)																//osw.write(char[])，写一个字符数组
		public void write(char[] cbuf, int off, int len)											//osw.write(char[], 开始索引, 长度)，写一个字符数组的一部分
		public void write(String str)																	//osw.write(String)，写一个字符串
		public void write(String str, int off, int len)											//osw.write(String, 开始索引, 长度)，写一个字符串的一部分
	InputStreamReader的重要方法：
		int read()																								//isr.read()，一次读取一个字符
		int read(char[] chs)																				//isr.read(char[])，一次读取一个字符数组
		
15.flush()方法相关
	概述：
		该方法是IO流根类OutputStream和Writer都有的方法，作用是刷新该流的缓冲，将流的缓冲中所有write()方法保存的内容写入到文件中。
	相关重要问题：
		close()和flush()的区别？
			A.close()关闭流对象，在关闭之前会刷新一次缓冲区。关闭之后流对象就不能继续使用了；
			B.flush()仅仅刷新缓冲区，刷新之后流对象还可以继续使用。
			
16.字符缓冲流BufferedWriter/BufferedReader
	概述：
		字符流为了高效读写，也提供了对应的字符缓冲流。
		BufferedWriter：字符缓冲输出流
			将文本写入字符输出流，缓冲各个字符，从而提供单个字符，数组和字符串的高效写入。
			可以指定缓冲区的大小，然而在大多数情况下，默认值就足够大了。
		BufferedReader：字符缓冲输入流
			从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。
			可以指定缓冲区大小，然而在大多数情况下，默认值就足够大了。
	重要构造方法：
		BufferedWriter(Writer out)																	//创建一个具有默认大小缓冲区的缓冲字符输出流
		BufferedReader(Reader in)																	//创建一个具有默认大小缓冲区的缓冲字符输入流
	重要特殊方法：
		BufferedWriter：
			public void newLine()																		//bw.newLine()，根据系统来写入换行符
		BufferedReader：
			public String readLine()																		//br.readLine()，一次读取一行数据。结束依据为任何换行符，返回的字符串不包含任何换行符。如果已达流末尾，返回null。
		
17.数据输入/输出流DataInputStream/DataOutputStream
	概述：
		操作基本数据类型的流。
	重要构造方法：
		DataInputStream(InputStream in)															//传一个InputStream构造DataInputStream对象
		DataOutputStream(OutputStream out)													//传一个OutputStream构造DataOutputStream对象
	重要方法：
		DataOutputStream：
			public final void write基本数据类型(基本数据类型对象)							//dos.writeInt(0)
		DataInputStream：
			public final 基本数据类型 read基本数据类型()										//dis.readInt()
			
18.内存操作流
	概述：
		用于临时存储信息，程序结束，临时存储的信息就从内存中消失。
		此种流的close()方法没有意义，因为其源码中没有任何内容，是空实现。
		此处将概述：
			字节数组内存操作流ByteArrayInputStream和ByteArrayOutputStream；
			字符数组内存操作流CharArrayReader和CharArrayWriter；
			字符串内存操作流StringReader和StringWriter。
	构造方法：
		输入流一般传入一个对应数据类型对象构造输入流对象。
		输出流一般使用空参构造，缓冲区会随着写入数据的增加自动扩充。
		也可以传一个size指定缓冲区大小，不过一般没有必要。
	字节数组内存操作流的使用举例（另外两个流类似）：
		// 写数据
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write("abc".getBytes());
		byte[] bys = baos.toByteArray();
		// 读数据
		ByteArrayInputStream bais = new ByteArrayInputStream(bys);
		int len = 0;
		byte[] arr = new byte[1024];
		while((len = bais.read(arr)) != -1) {
			System.out.println(new String(arr, 0, len));
		}
		
19.打印流
	概述：
		打印流包括字节打印流PrintStream和字符打印流PrintWriter
	打印流的特点：
		1）只有写数据的，没有读取数据的。只能操作目的地，不能操作数据源；
		2）可以操作任意类型的数据；
		3）如果启用了自动刷新，可以自动进行刷新无需手动flush()；
		4）该流可以直接操作文本文件（不像缓冲流需要传一个操作文件的基本流）。
			所以，常用的可以直接操作文本文件的流有：
				FileInputStream，FileOutputStream，FileReader，FileWriter，PrintStream，PrintWriter
	PrintWriter概述：
		重要构造方法：
			可以传一个File或文件名字符串构造打印输出流，不过这样将不能自动刷新。
			也可以传一个字节输出流OutputStream或字符输出流Writer，这种方式若想要自动刷新，需第二参数boolean autoFlush。
			public PrintWriter(OutputStream out, boolean autoFlush)					//需注意print()方法不能自动刷新，println()才可以
			public PrintWriter(Writer out, boolean autoFlush)
		使用举例：
			PrintWriter pw = new PrintWriter(new FileWriter("demo.txt"), true);
			pw.println("hello");
			pw.println("100");
			//此处println()一个方法相当于BufferedWriter的bw.write()，bw.newLine()，bw.flush()三者的组合。
			
20.标准输入/输出流
	概述：
		System类中的字段in和out。
		分别代表了系统标准的输入和输出设备，默认输入设备是键盘，默认输出设备是显示器。
		System.in的类型为InputStream，System.out的类型为PrintStream（字节打印流，OutputStream的子类FilterOutputStream的子类）。
	相关问题：
		键盘录入数据的三种方式：
			1）main方法的参数String[] args数组接收参数，举例：
				java HelloWorld hello world java
			2）Scanner（JDK5后），举例：
				Scanner sc = new Scanner(System.in);
				sc.nextInt();
			3）通过字符缓冲输入流BufferedReader包装标准输入流实现（BufferedReader需要一个Reader，通过InputStreamReader包装System.in实现）,举例：
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String line = br.readLine();
				
21.随机访问流RandomAccessFile
	概述：
		（可以在文件指定位置进行读写操作）
		支持对文件的随机访问和写入。
		RandomAccessFile包含了一个记录指针以标识当前独写的位置。当新创建对象时，指针位于文件开头；读/写了n个字节后，指针也会向后移动n个字节。
		RandomAccessFile在io包下，不过不属于任何一个io流根类，其继承自Object。
		融合了InputStream和OutputStream的功能。
		RandomAccessFile不能向指针位置（除末尾）插入内容（将会覆盖原本存在的内容）。若想插入内容，可以先将指针后的内容存储到临时文件，追加内容，最后追加临时文件中的内容。
	重要构造方法：
		public RandomAccessFile(String name, String mode)							//第一个参数可以是文件或文件名，第二个参数为操作文件的模式，有"r"，"rw"，"rws"，"rwd"可选。常用"rw"进行读写。
	重要方法：
		public long getFilePointer()																	//raf.getFilePointer()，返回文件记录指针的当前位置
		public long seek(long pos)																	//raf.seek(偏移量)，将文件记录指针设置到pos位置
		InputStream具有的三个read()方法															//单个字节，字节数组，字节数组的一部分
		OutputStream具有的三个write()方法														//单个字节，字节数组，字节数组的一部分
		
22.合并流SequenceInputStream
	概述：
		（将多个字节输入流合并为一个）
		表示其他输入流的逻辑串联。将会从第一个（输入流的有序集合第一个）开始，读完了读第二个，直到最后一个读完为止。
		继承自InputStream。
	重要构造方法：
		public SequenceInputStream(InputStream s1, InputStream s2)				//创建包含两个InputStream的合并流，先读s1后读s2
		public SequenceInputStream(Enumeration<? extends InputStream> e)//可以进行多个流的合并，具体说明如下：
	Enumeration构造方法的具体说明：
		Enumeration是有序集合Vector中public Enumeration<E> elements()方法的返回值，有序包含Vector中所有元素。
		使用该种构造方法，需要先创建Vector集合对象，然后将多个InputStream添加到集合，最后调用集合的elements方法得到Enumeration（枚举）对象，以构造合并流对象。
		
23.序列化流ObjectInputStream/ObjectOutputStream
	概述：
		（把对象存入文件/从文件读出对象）
		把对象按照流一样的方式存入文本文件或者在网络中传输/把文本文件或网络中的流对象数据还原成对象。
		注意，写入和读取的对象需要实现Serializable接口，否则在操作的时候会抛出NotSerializableException。
		Serializable为标记接口，内部没有任何方法。
	重要构造方法：
		public ObjectInputStream(InputStream in)											//创建从指定InputStream读取的ObjectInputStream
		public ObjectOutputStream(OutputStream out)									//创建用指定OutputStream输出的ObjectOutputStream
	重要方法：
		public final Object readObject()															//ois.readObject()，从ObjectInputStream中读取Object对象
		public final void writeObject(Object o)													//oos.writeObject(Object)，将指定对象写入ObjectOutputStream
	注意事项：
		1）如果写入一个已序列化类的对象，之后对该类的Java文件进行了改动，再执行读取的时候会报错。
			要解决该问题，可以点击IDE中黄色叹号，自动生成成员变量序列化ID值。
			该方式同时也可以去除黄色警告线。
		2）若不想实例化某成员变量，可以用关键字transient修饰。
		
24.属性集合类Properties
	概述：
		（可以和IO流相结合使用的Map集合类）
		该类的对象可以保存在流中或从流中加载，属性列表中每一个键及其对应值都是一个字符串。
		是Hashtable的子类，是一个map集合。
	重要构造方法：
		public Properties()																				//创建一个无默认值的空属性列表
	重要特殊方法：
		public Object setProperty(String key, String value)								//p.setProperty(str1, str2)，添加元素（原理为调用父类Hashtable的put()）
		public String getProperty(String key)														//p.getProperty(key)，根据键找值
		public Set<String> stringPropertyNames()											//p.stringPropertyNames()，获取所有键的集合
		
		public void load(Reader reader)															//p.load(Reader)，把文件中的数据读取到集合中
		public void store(Writer writer, String comments)									//p.store(Writer, 注释)，把集合中的数据和注释存储到文件，注释可以为null
	存储到文件中的格式：
		#comments
		#时间
		键1=值1
		键2=值2
		...
		
25.nio（新IO）
	概述：
		于JDK4出现nio，其和传统io有着相同的目的，都是用于输入和输出。不过新io采用了不同的处理方式，其原理是将文件或文件的一段区域映射到内存，像访问内存一样访问文件，效率更高。
		目前旧io使用较多，此处内容仅需了解。
	了解内容：
		Path（1.7）：
			为java.nio.file包下一个接口，表示路径。
		Paths（1.7）：
			一个最终类，其中有一个静态方法static Path get(URI uri)，根据给定URI确定文件路径。
		Files（1.7）：
			操作文件的工具类，方法全部为静态。
			需要了解的方法：
				public static long copy(Path source, OutputStream out)				//Files.copy(Path, OutputStream)，将一个文件中的全部字节复制到一个OutputStream
				public static Path write(Path path, Iterable<? extends CharSequence> lines, Charset cs, OpenOption... options)
					//把集合的元素写到文件
		使用举例：
			Files.copy(Paths.get("Demo.java"), new FileOutputStream("Copy.java"));		//复制文件
			File.write(Paths.get("List.txt"), new ArrayList<String>(...), Charset.forName("GBK"));		//将集合的元素写到文件
			
26.多线程概述
	由于线程是依赖于进程而存在，所以先了解进程。
	进程：
		就是正在运行的程序。
		进程是系统进行资源分配和调用的独立单位，没一个进程都有它自己的内存空间和系统资源。
	多进程的意义：
		1）可以在一个时间段内执行多个任务；
		2）可以提高CPU的使用率。
	线程：
		同一个进程内又可能包含多个任务，这每一个任务就可以看成是一个线程。
		线程是程序的执行单元/执行路径，是程序使用CPU的基本单位。
		如果程序只有一条执行路径即为单线程，如果程序有多条执行路径即为多线程。
	多线程的意义：
		提高应用程序的使用率。
		如果一个进程有多个线程，将会有更高的几率获得更多系统资源。
	并行和并发：
		并行：是指逻辑上同时发生，在某一个时间段内同时运行多个程序。
		并发：是指物理上同时发生，在某一个时间点上同时运行多个程序。
	Java程序的运行原理：
		java命令会先启动Java虚拟机（JVM），也就是启动了一个程序（启动了一个进程）。该程序会启动一个主线程，然后该线程去调用某个类的main方法。
	相关问题：
		多个进程在单CPU上是同时进行的吗？
			不是，因为单CPU在某一个时间点上只能做一件事情。
			我们感觉到的同时进行，是因为CPU在做着进程间的高效切换。
		Java虚拟机的启动是单线程的还是多线程的？
			是多线程的。
			因为至少启动了主线程和垃圾回收器线程。
			
27.多线程程序的实现
	如何实现：
		由于线程是依赖进程存在的，所以首先应创建一个进程。
		进程是由系统创建的，所以我们需要调用系统功能去创建一个进程。
		Java不能直接调用系统功能，没有办法直接实现多线程程序，不过可以通过调用C/C++写好的程序来实现。
		将C/C++写好的程序功能封装成Java类，就可以实现Java多线程程序了。
	Java提供的线程类是：
		Thread
	实现Java多线程程序的两种方法：
		方式一：
			1）自定义类MyThread继承自Thread类；
			2）MyThread类里面重写run()方法；
			3）创建对象；
			4）启动线程。
			实例：
				public class MyThread extends Thread{
					public void run() {
						...(线程中要执行的内容)
					}
				}
				public class Demo{
					public static void main(String[] args){
						MyThread tr1 = new MyThread();
						MyThread tr2 = new MyThread();
						
						// tr1.setName("线程1")；
						// tr2.setName("线程2")；
						
						tr1.start();									//启动线程，如果调用run()方法，只是相当于走了一遍run()中的代码
						tr2.start();
					}
				}
		方式二：
			1）自定义类MyRunnable实现接口Runnable；
			2）重写run()方法；
			3）创建MyRunnable类的对象；
			4）创建Thread类的对象，并把C步骤的对象当成参数传递；
			5）启动线程。
			实例：
				public class MyRunnable implements Runnable{
					public void run(){
						...(线程中要执行的内容)
					}
				}
				public class Demo{
					public static void main(String[] args){
						MyRunnable mr = new MyRunnable();
						
						Thread th1 = new Thread(mr, "线程1")；
						Thread th2 = new Thread(mr)；
						
						th1.start();
						th2.start();
					}
				}
	相关重要问题：
		1）为什么要重写run()方法？
			不是类中所有代码都要被线程执行的。
			为了区分哪些代码需要被线程执行，Java提供了Thread中的run()方法来包含被线程执行的代码。
		2）调用run()方法为什么是单线程的呢？
			因为run()方法的调用其实就相当于普通的方法调用，看到的自然是单线程的效果。
		3）run()和start()的区别？
			run()：仅仅是封装需要被线程执行的代码，直接调用仅相当于普通方法调用。
			start()：启动线程，然后Java虚拟机调用该线程的run()方法。
		4）线程能不能多次启动？
			不能。
			不过可以创建不同的线程对象分别启动。
		5）多线程实现方式二的好处？
			1）若一个类已经继承了其他类就无法使用方式一了，使用接口可以避免Java单继承带来的局限性；
			2）方式二可以实现多个相同线程处理同一份资源。
				把线程同程序的代码、数据有效分离，较好地体现了面向对象的设计思想。
		
28.Thread类
	概述：
		Thread是程序中的执行线程。
	重要构造方法：
		public Thread()										//分配新的Thread对象，自动生成的名称的形式为"Thread-" + n
		public Thread(String name)					//使用给定的名称构造新的Thread对象
		public Thread(Runable target)				//传一个Runnable实现类，构造Thread对象
		public Thread(Runable target, String name)		//传一个Runnable实现类和线程名称，构造Thread对象
	重要方法：
		public final void setName(String name)		//th.setName("线程名")，设置线程名称
		public final String getName()						//th.getName()，返回线程名称
		public void run()											//th.run()，Thread的子类应该重写该方法
		public void start()											//th.start()，使该线程开始执行，Java虚拟机调用该线程的run()方法
		public static Thread currentThread()				//Thread.currentThread()，返回当前正在执行的Thread对象
		public final int getPriority()							//th.getPriority()，返回线程对象的优先级
		public final void setPriority(int newPriority)	//th.setPriority()，更改线程的优先级
		public static void sleep(long millis)				//Thread.sleep(毫秒数)，在指定的毫秒数内让正在执行的线程休眠（暂停执行），此操作受系统计时器、调度精度等因素影响
		public final void join()									//th.join()，等待该线程终止
		public static void yield()								//Thread.yield()，暂停当前正在执行的线程对象，并执行其他线程
		public final void setDaemon(boolean on)		//th.setDaemon()，将该线程标记为守护线程/用户线程/后台线程。当正在运行的线程都是守护线程时，Java虚拟机退出。必须在启动线程前调用
		public void interrupt()									//th.interrupt()，中断线程。把线程的状态终止，并抛出一个InterruptedException
		public final void stop()									//th.stop()，已过时，强迫线程终止执行。
		
29.线程调度
	概述：
		线程只有得到CPU的使用权，才可以执行指令。
		线程有两种调度模型：
			1）分时调度模型
				所有线程轮流获得CPU的使用权，平均分配每个线程占用CPU的时间片。
			2）抢占式调度模型：
				优先让优先级高的线程使用CPU。
				如果线程的优先级相同，会随机选择一个。
				优先级高的线程获得的CPU时间片会多一些。
		Java使用的是抢占式调度模型。
	Java线程优先级：
		线程默认优先级是：5
		线程优先级的范围是：1 - 10
		线程优先级高表示线程获取CPU时间片的几率高，调用次数越多将越能体现这一点，次数少会更多的表现出随机性。
	相关异常：
		IllegalArgumentException：非法参数异常
			抛出此异常表明向方法传递了一个不合法或不正确的参数。
			
30.线程控制
	线程休眠：
		在线程的run()方法内静态调用sleep(long millis)方法，可将当前实例休眠指定的毫秒数。
	线程加入：
		th.join()，将等待该线程终止才会去执行其他线程/执行后面的代码。
	线程礼让：
		在线程的run()方法内静态调用yield()方法，暂停当前正在执行的线程对象，并执行其他线程。
	后台线程/守护线程：
		（必须）在启动线程前调用th.setDaemon(boolean on)方法，可以将该线程标记为守护线程/后台线程。
		当所有正在运行的线程都是守护线程时，Java虚拟机退出。
	线程终止：
		th.interrupt()，把线程的状态终止，并抛出一个InterruptedException。
		
31.线程生命周期
	1）新建
		创建线程对象。
		调用start()方法可进入就绪状态。
	2）就绪
		有执行资格，没有执行权。
		若得到了CPU的执行权即进入运行状态。
	3）运行
		有执行资格，有执行权。
		若被别的线程得到了CPU执行权，则回到就绪状态。
		若运行了sleep()或wait()等方法，则进入阻塞状态。
		若run()方法执行结束或中断了线程，进入死亡状态。
	4）阻塞
		没有执行资格，没有执行权。
		若sleep()时间到或运行了notify()等方法，可恢复到就绪状态。
	5）死亡
		线程对象变成垃圾，等待被回收。
		
32.线程安全问题/线程同步
	是否存在线程安全问题的标准：
		1）是否多线程环境；
		2）是否有共享数据
		3）是否有多条语句操作共享数据。
	解决方案（同步代码块）：
		格式：
			synchronized (对象) {
				...需要同步的代码
			}
		小括号内所传的对象是重点，该对象相当于“锁”的功能，多个线程对象需要同一把锁（相同的对象）。
	同步的前提：
		1）要有多个线程；
		2）多个线程使用的是同一个锁对象。
	同步的好处：
		同步的出现解决了多线程的安全问题。
	同步的弊端：
		当线程很多时，每个线程都会去判断同步上的锁。
		这将会耗费更多资源，降低程序运行效率。
	相关问题：
		1）同步代码块的锁对象是什么？
			是任意对象。
		2）同步方法的格式及锁对象问题：
			同步方法格式：synchronized关键字作为方法修饰符，如：
				public synchronized method ( ) { }
			同步方法的锁对象是什么？
				是this。
		3）静态方法的锁对象是什么？
			是类的字节码文件对象（demo.class）。