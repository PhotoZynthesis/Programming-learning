<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<title>Spring</title>
<link rel='stylesheet' type='text/css' href='../../css/markdown.css'>

</head>
<body>
<h1 id="spring-framework">Spring Framework</h1>
<ul>
<li><a href="#1-spring-概述">1. Spring 概述</a>
<ul>
<li><a href="#11-spring-概述">1.1 Spring 概述</a></li>
<li><a href="#12-spring-的优势">1.2 Spring 的优势</a></li>
</ul>
</li>
<li><a href="#2-ioc概述">2. IOC：概述</a>
<ul>
<li><a href="#21-ioc-的概述">2.1 IOC 的概述</a></li>
<li><a href="#22-耦合的概述">2.2 ''耦合''的概述</a></li>
</ul>
</li>
<li><a href="#3-iocxml实现">3. IOC：XML实现</a>
<ul>
<li><a href="#31-准备工作">3.1. 准备工作</a></li>
<li><a href="#32-xml-中的配置">3.2 XML 中的配置</a></li>
<li><a href="#4-容器相关-java-类">4. 容器相关 Java 类</a></li>
</ul>
</li>
<li><a href="#5-di概述">5. DI：概述</a></li>
<li><a href="#6-di实现">6. DI：实现</a>
<ul>
<li><a href="#61-通过构造方法注入">6.1 通过构造方法注入</a></li>
<li><a href="#62-通过-set-方法注入">6.2 通过 set 方法注入</a></li>
<li><a href="#63-通过-p名称空间-注入">6.3 *通过 p名称空间 注入</a></li>
<li><a href="#64-注入数组与集合">6.4 注入数组与集合</a></li>
</ul>
</li>
<li><a href="#7-iocdi注解实现">7. IOC/DI：注解实现</a>
<ul>
<li><a href="#71-准备工作">7.1 准备工作</a></li>
<li><a href="#72-创建对象的标签">7.2 创建对象的标签</a></li>
<li><a href="#73-注入数据的标签">7.3 注入数据的标签</a></li>
<li><a href="#74-生命周期与作用范围相关标签">7.4 生命周期与作用范围相关标签</a></li>
</ul>
</li>
<li><a href="#8-ioc配置类注解实现">8. IOC：配置类+注解实现</a>
<ul>
<li><a href="#81-创建配置类--获取容器">8.1 创建配置类 &amp; 获取容器</a></li>
<li><a href="#82-包扫描">8.2 包扫描</a></li>
<li><a href="#83-任意方法定义-bean">8.3 任意方法定义 bean</a></li>
<li><a href="#84-引入外部-properties-文件">8.4 引入外部 properties 文件</a></li>
<li><a href="#85-引入其他配置类">8.5 引入其他配置类</a></li>
</ul>
</li>
<li><a href="#9-aop概述">9. AOP：概述</a>
<ul>
<li><a href="#91-aop-的概述">9.1 AOP 的概述</a></li>
<li><a href="#92-aop-的优势">9.2 AOP 的优势</a></li>
<li><a href="#93-相关术语">9.3 相关术语</a></li>
</ul>
</li>
<li><a href="#10-aopxml-实现">10. AOP：XML 实现</a>
<ul>
<li><a href="#101-准备工作">10.1 准备工作</a></li>
<li><a href="#102-相关标签">10.2 相关标签</a></li>
<li><a href="#103-切入点表达式">10.3 切入点表达式</a></li>
<li><a href="#104-环绕通知">10.4 环绕通知</a></li>
<li><a href="#105-示例">10.5 示例</a></li>
</ul>
</li>
<li><a href="#11-aop注解实现">11. AOP：注解实现</a>
<ul>
<li><a href="#111-简要流程概述">11.1 简要流程概述</a></li>
<li><a href="#112-定义可重用的切入点表达式">11.2 定义可重用的切入点表达式</a></li>
<li><a href="#113-使用配置类来开启注解-aop-支持">*11.3 使用配置类来开启注解 AOP 支持</a></li>
</ul>
</li>
<li><a href="#12-事务控制xml-实现">12. 事务控制：XML 实现</a>
<ul>
<li><a href="#120-spring-事务控制-api-概述">*12.0 Spring 事务控制 API 概述</a></li>
<li><a href="#121-准备工作">12.1 准备工作</a></li>
<li><a href="#122-配置步骤">12.2 配置步骤</a></li>
</ul>
</li>
<li><a href="#12-事务控制注解实现">12. 事务控制：注解实现</a></li>
<li><a href="#-组件junit-整合">#. 组件：Junit 整合</a></li>
<li><a href="#-组件spring-jdbc-template">#. 组件：Spring JDBC Template</a>
<ul>
<li><a href="#1-概述">#.1 概述</a></li>
<li><a href="#2-maven添加依赖">#.2 Maven添加依赖</a></li>
<li><a href="#3-使用步骤">#.3 使用步骤</a></li>
</ul>
</li>
</ul>
<h2 id="1-spring-概述">1. Spring 概述</h2>
<h3 id="11-spring-概述">1.1 Spring 概述</h3>
<ul>
<li>Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 **IoC（Inverse Of Control： 反转控制）**和 **AOP（Aspect Oriented Programming：面向切面编程）**为内核。</li>
<li>提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术。</li>
<li>还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。</li>
</ul>
<h3 id="12-spring-的优势">1.2 Spring 的优势</h3>
<ul>
<li>
<p><strong>方便解耦，简化开发</strong></p>
<p>通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造 成的过度程序耦合。</p>
</li>
<li>
<p><strong>AOP 编程支持</strong></p>
<p>通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。</p>
</li>
<li>
<p>**声明式事务的支持 **</p>
<p>通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。</p>
</li>
<li>
<p>**方便程序的测试 **</p>
<p>可以用非容器依赖的编程方式进行几乎所有的测试工作。</p>
</li>
<li>
<p>**方便集成各种优秀框架 **</p>
<p>Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。</p>
</li>
<li>
<p>**降低 JavaEE API的使用难度 **</p>
<p>Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。</p>
</li>
</ul>
<h2 id="2-ioc概述">2. IOC：概述</h2>
<h3 id="21-ioc-的概述">2.1 IOC 的概述</h3>
<p>IOC（Inversion Of Control），即<strong>控制反转</strong>。</p>
<ul>
<li>把创建对象的权力交给框架，是框架的重要特征。</li>
<li>以此来降低程序（类）之间的耦合。</li>
<li>包括 DI（依赖注入）和 依赖查找。</li>
</ul>
<h3 id="22-耦合的概述">2.2 ''耦合''的概述</h3>
<ul>
<li>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。</li>
<li>耦合性的强弱取决于多种因素，如模块间接口的复杂性、调用模块的方式等。</li>
<li>对象之间的<strong>耦合越高</strong>，<strong>维护成本越高</strong>。因此对象的设计应使类和构件之间的耦合最小。</li>
</ul>
<h2 id="3-iocxml实现">3. IOC：XML实现</h2>
<h3 id="31-准备工作">3.1. 准备工作</h3>
<ul>
<li>
<p><strong>导入包</strong>：</p>
<ul>
<li>下载：</li>
</ul>
<p>https://repo.spring.io/libs-release-local/org/springframework/spring/</p>
<ul>
<li>Maven：</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<h3 id="32-xml-中的配置">3.2 XML 中的配置</h3>
<h4 id="321-创建-xml-文件">3.2.1 创建 xml 文件</h4>
<ul>
<li>
<p>在 src/resources根路径 下创建<strong>任意名称</strong>的 xml 文件。</p>
</li>
<li>
<p>在xml中添加头部与约束。约束可以在官网 ctrl + F 搜索 <code>configuration</code>或<code>xml</code>查找，示例如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
...
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h4 id="322-bean-标签及其属性">3.2.2 bean 标签及其属性</h4>
<p>bean 标签位于 Spring 容器 xml 文件的根标签<code>beans</code>下，用于配置对象来让 Spring 创建。</p>
<ul>
<li>
<p><strong>重要属性</strong>：</p>
<ul>
<li>id：设置 bean 在容器中的唯一标识。</li>
<li>class：类的完整类名，用于反射创建对象。</li>
<li>scope：指定对象的作用范围/单例多例等。可取值：</li>
<li><strong>singleton</strong>：单例对象，默认值。</li>
<li><strong>prototype</strong>：多例对象。</li>
<li>request：WEB项目中，将创建的 Bean 存入 request 域中。</li>
<li>session：WEB项目中，将创建的 Bean 存入 session 域中。</li>
<li>global session：应用于 Portlet 环境的 WEB 项目中，将创建的对象存入多台服务器的共享域中。若不是 Portlet 环境则相当于 session 。</li>
<li>init-method：指定初始化之后的回调方法，不能有返回值。</li>
<li>destroy-method：指定销毁之前的回调方法，不能有返回值。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;io.github.photozynthesis.dao.UserDao&quot; scope=&quot;prototype&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h4 id="323-spring-容器中-bean-的生命周期">3.2.3 Spring 容器中 Bean 的生命周期</h4>
<ul>
<li>
<p><strong>单例对象</strong>：</p>
<ul>
<li>一个应用只存在一个的对象。</li>
<li>与容器共存，仅当容器销毁时才销毁。</li>
</ul>
</li>
<li>
<p><strong>多例对象</strong>：</p>
<ul>
<li>每次从容器获取时，都会重新创建对象实例。</li>
<li>由 Java 垃圾回收器管理，一般长时间不使用即被回收。</li>
</ul>
</li>
</ul>
<h4 id="324-spring-容器实例化-bean-的三种方式">3.2.4 Spring 容器实例化 Bean 的三种方式</h4>
<ul>
<li>
<p><strong>构造方法实例化</strong>：</p>
<ul>
<li>
<p>bean 标签使用 id 和对应 class 属性。</p>
</li>
<li>
<p>id：唯一标识</p>
</li>
<li>
<p>class：全路径类名</p>
</li>
<li>
<p>默认使用无参构造方法，没有无参构造方法将会报错；有参相关参考依赖注入。</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-xml">&lt;beans ......&gt;
	&lt;bean id=&quot;userDao&quot; class=&quot;io.github.photozynthesis.dao.UserDao&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p><strong>普通工厂实例化</strong>：</p>
<ul>
<li>
<p>需要先将工厂交由 spring 管理，再指定 bean 的工厂 id 和 对应方法。</p>
</li>
<li>
<p>id：唯一标识</p>
</li>
<li>factory-bean：工厂 bean 的 id</li>
<li>
<p>factory-method：工厂中实例化该对象的方法</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-xml">&lt;beans ......&gt;
	&lt;bean id=&quot;instanceFactory&quot; class=&quot;io.github.photozynthesis.factory.InstanceFactory&quot; /&gt;
    &lt;bean id=&quot;instance&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;createInstance&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p><strong>静态工厂实例化</strong>：</p>
<ul>
<li>
<p>使用静态工厂中的静态方法创建对象，并将对象存入 spring 容器。</p>
</li>
<li>
<p>id：唯一标识</p>
</li>
<li>class：静态工厂的完整类名</li>
<li>
<p>factory-method：静态工厂中产生对象的静态方法</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-xml">&lt;beans ......&gt;
	&lt;bean id=&quot;instance&quot; class=&quot;io.github.photozynthesis.factory.StaticFactory&quot; factory-method=&quot;createInstance&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="4-容器相关-java-类">4. 容器相关 Java 类</h3>
<ul>
<li>
<p><strong>常用类/接口体系结构</strong>：</p>
<blockquote>
<p>|--- interface <strong>BeanFactory</strong></p>
<p>​	| --- interface <strong>ApplicationContext</strong></p>
<p>​		| --- class <strong>ClassPathXmlApplicationContext</strong></p>
<p>​		| --- class <strong>FileSystemXmlApplicationContext</strong></p>
<p>​		| --- class <strong>AnnotationConfigApplicationContext</strong></p>
</blockquote>
</li>
<li>
<p><strong>接口 BeanFactory</strong>：</p>
<ul>
<li>Spring 容器的顶层接口。</li>
<li>需要使用实例时才创建对象。</li>
</ul>
</li>
<li>
<p><strong>接口 ApplicationContext</strong>：</p>
<ul>
<li>默认只要一读取配置文件，即创建对象。</li>
</ul>
</li>
<li>
<p><strong>类 ClassPathXmlApplicationContext</strong>：</p>
<ul>
<li>从类的根路径下加载配置文件，推荐使用。</li>
</ul>
</li>
<li>
<p><strong>类 FileSystemXmlApplicationContext</strong>：</p>
<ul>
<li>可以从磁盘任意位置加载配置文件。</li>
</ul>
</li>
<li>
<p><strong>类 AnnotationConfigApplicationContext</strong>：</p>
<ul>
<li>读取注解配置容器的对象（配置 Java 类）。</li>
</ul>
</li>
</ul>
<h2 id="5-di概述">5. DI：概述</h2>
<ul>
<li>DI（Dependency Injection），即依赖注入，是 IOC 的具体实现。</li>
<li>依赖注入是将所需要的依赖传递给将使用的从属对象。</li>
<li>此处的依赖注入通过配置的方式，由 spring 完成，并非手动注入。</li>
</ul>
<h2 id="6-di实现">6. DI：实现</h2>
<h3 id="61-通过构造方法注入">6.1 通过构造方法注入</h3>
<ul>
<li>
<p>说明：</p>
<ul>
<li>bean 中需要有 具有对应参数列表的构造方法。</li>
</ul>
</li>
<li>
<p>使用的子标签及其属性：</p>
<p><code>constructor-arg</code>：每一个子标签对应一个参数，常用属性如下：</p>
<ul>
<li>指定给哪个参数赋值，通常是第一个属性：</li>
<li>index：指定参数在构造方法参数列表中对应的索引，从 0 开始</li>
<li>type：指定参数在构造方法中的数据类型</li>
<li>name：指定参数在构造方法中的名称，一般多使用这个</li>
<li>指定该参数所赋的值，通常是第二个属性：</li>
<li>value：可以赋基本类型和 String</li>
<li>ref：可以赋其他 bean 类型，不过需要在容器配置过 bean，此处输入 bean 的 id</li>
</ul>
</li>
<li>
<p>示例：</p>
<pre><code class="language-xml">&lt;beans ......&gt;
&lt;bean id=&quot;user&quot; class=&quot;io.github.photozynthesis.domain.User&quot;&gt;
  	&lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot; /&gt;
      &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot; /&gt;
      &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot; /&gt;
  &lt;/bean&gt;
  &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;
  	...
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="62-通过-set-方法注入">6.2 通过 set 方法注入</h3>
<ul>
<li>
<p>说明：</p>
<ul>
<li>bean 中需要有对应 set 方法</li>
</ul>
</li>
<li>
<p>使用的子标签及其属性：</p>
<p><code>property</code>：</p>
<ul>
<li>指定给哪个参数赋值，通常是第一个属性：</li>
<li>name：类中 set 方法后面的部分，如<code>setName()</code> -&gt; <code>name</code></li>
<li>指定该参数所赋的值，通常是第二个属性：</li>
<li>value：可以赋基本类型和 String</li>
<li>ref：可以赋其他 bean 类型，不过需要在容器配置过 bean，此处输入 bean 的 id</li>
</ul>
</li>
<li>
<p>示例：</p>
<pre><code class="language-xml">&lt;beans ......&gt;
&lt;bean id=&quot;user&quot; class=&quot;io.github.photozynthesis.domain.User&quot;&gt;
  	&lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
      &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
      &lt;property name=&quot;birthday&quot; ref=&quot;now&quot; /&gt;
  &lt;/bean&gt;
  &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;
  	...
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="63-通过-p名称空间-注入">6.3 *通过 p名称空间 注入</h3>
<ul>
<li>
<p>说明：</p>
<ul>
<li>不常用</li>
<li>本质上也是通过 set 方法注入，只是将内容的位置由 bean 的子标签转移到了 bean 的属性。</li>
<li>beans 标签需要加一条约束。</li>
</ul>
</li>
<li>
<p>示例：</p>
<pre><code class="language-xml">&lt;!-- 添加的约束为第二条 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 					   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;user&quot; class=&quot;io.github.photozynthesis.domain.User&quot; p:name=&quot;zhangsan&quot; p:age=&quot;20&quot; p:birthday-ref=&quot;now&quot; /&gt;
  &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="64-注入数组与集合">6.4 注入数组与集合</h3>
<ul>
<li>
<p>说明：</p>
<ul>
<li>针对 bean 的属性为数组或集合的情况</li>
<li>此处介绍：</li>
<li>List结构：array，list，set</li>
<li>Map结构：map，entry，props，prop</li>
<li>相同结构的对应标签可以互换，具体见下方示例。</li>
</ul>
</li>
<li>
<p>示例：</p>
<p>已知存在 bean 类，其中有数组、单列集合、双列集合等五个属性。</p>
<p>xml：</p>
<pre><code class="language-xml">&lt;beans ......&gt;
&lt;bean id=&quot;myCollections&quot; class=&quot;io.github.photozynthesis.domain.MyCollections&quot;&gt;
      &lt;!-- 注入数组，标签已替换 --&gt;
  	&lt;property name=&quot;myStrArray&quot;&gt;
      	&lt;set&gt;
          	&lt;value&gt;AAA&lt;/value&gt;
              &lt;value&gt;BBB&lt;/value&gt;
              &lt;value&gt;CCC&lt;/value&gt;
          &lt;/set&gt;
      &lt;/property&gt;
      &lt;!-- 注入List集合，标签已替换 --&gt;
  	&lt;property name=&quot;myList&quot;&gt;
      	&lt;array&gt;
          	&lt;value&gt;AAA&lt;/value&gt;
              &lt;value&gt;BBB&lt;/value&gt;
              &lt;value&gt;CCC&lt;/value&gt;
          &lt;/array&gt;
      &lt;/property&gt;
      &lt;!-- 注入Set集合，标签已替换 --&gt;
  	&lt;property name=&quot;mySet&quot;&gt;
      	&lt;list&gt;
          	&lt;value&gt;AAA&lt;/value&gt;
              &lt;value&gt;BBB&lt;/value&gt;
              &lt;value&gt;CCC&lt;/value&gt;
          &lt;/list&gt;
      &lt;/property&gt;
      &lt;!-- 注入Map集合 --&gt;
      &lt;property name=&quot;myMap&quot;&gt;
      	&lt;map&gt;
          	&lt;entry key=&quot;key1&quot;&gt;
              	&lt;value&gt;value1&lt;/value&gt;
              &lt;/entry&gt;
              &lt;entry key=&quot;key2&quot; value=&quot;value2&quot; /&gt;
          &lt;/map&gt;
      &lt;/property&gt;
      &lt;!-- 注入Properties数据 --&gt;
      &lt;property name=&quot;myProp&quot;&gt;
          &lt;prop key=&quot;key1&quot; value=&quot;value1&quot; /&gt;
      	&lt;prop key=&quot;key2&quot; value=&quot;value2&quot; /&gt;
      &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h2 id="7-iocdi注解实现">7. IOC/DI：注解实现</h2>
<h3 id="71-准备工作">7.1 准备工作</h3>
<ul>
<li>
<p><strong>导入包</strong>：</p>
<p>在xml配置的基础上，需要导入<code>spring-aop</code>包，不过一般导入<code>spring-context</code>即已自动导入。</p>
</li>
<li>
<p><strong>创建 xml 配置文件</strong>：</p>
<p>若要使用注解配置，相比于纯 xml 配置需要在 beans 标签上多加一条约束，新加的约束是 context：</p>
<blockquote>
<p>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</p>
<p><strong>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</strong></p>
<p>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</p>
<p>xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</p>
<p>http://www.springframework.org/schema/beans/spring-beans.xsd</p>
<p><strong>http://www.springframework.org/schema/context</strong></p>
<p><strong>http://www.springframework.org/schema/context/spring-context.xsd</strong>&quot;&gt; ​	... </beans></p>
</blockquote>
<p>加粗部分为新加入部分。</p>
</li>
</ul>
<h3 id="72-创建对象的标签">7.2 创建对象的标签</h3>
<ul>
<li><strong>@Component</strong>：
<ul>
<li>位置：bean 类的声明上</li>
<li>说明：通用的标签，用于配置一个 bean 以加入 spring 容器</li>
<li>属性：value -&gt; 指定 bean 的 id，若不指定则为首字母小写的类名</li>
</ul>
</li>
<li><strong>@Controller &amp; @Service &amp; @Repository</strong>：
<ul>
<li>都是 <code>@Component</code> 的衍生注解，使用方法和功能一模一样。</li>
<li>更加语义化，增加辨识度。</li>
</ul>
</li>
</ul>
<h3 id="73-注入数据的标签">7.3 注入数据的标签</h3>
<ul>
<li><strong>说明</strong>：
<ul>
<li>只使用注解注入属性，可以不写 set 方法。其实甚至连构造方法都不需要，底层是暴力反射。</li>
</ul>
</li>
<li><strong>@Autowired</strong>：
<ul>
<li>位置：bean 的成员变量上。</li>
<li>说明：只能注入 bean 类型。</li>
<li>注入规则：</li>
<li>首先自动按照<strong>类型</strong>注入，容器中只有一个对应类型的 bean 时有效</li>
<li>容器中有多个匹配类型的 bean 时，找到 id 与当前变量名一致的 bean 来注入</li>
<li>若上一条没找到，报错</li>
<li>属性：无</li>
</ul>
</li>
<li><strong>@Qualifier</strong>：
<ul>
<li>位置：bean 的成员变量上。</li>
<li>说明：按照类型+id 给成员变量注入值，需要和<code>@Autowired</code>一起使用。只能注入 bean 类型。</li>
<li>属性：</li>
<li>value（默认）：bean 的 id</li>
</ul>
</li>
<li><strong>@Resource</strong>：
<ul>
<li>位置：bean 的成员变量上。</li>
<li>说明：只能注入 bean 类型，直接按照 id 注入。</li>
<li>属性：</li>
<li>name：bean 的 id</li>
</ul>
</li>
<li><strong>@Value</strong>：
<ul>
<li>位置：bean 的成员变量上。</li>
<li>说明：只能注入基本类型和 String 。</li>
<li>属性：</li>
<li>value（默认）：值。</li>
</ul>
</li>
</ul>
<h3 id="74-生命周期与作用范围相关标签">7.4 生命周期与作用范围相关标签</h3>
<ul>
<li><strong>@PostConstruct</strong>：
<ul>
<li>位置：bean 的成员方法上。</li>
<li>说明：指定 bean 的初始化方法，在实例化完成后执行。</li>
<li>属性：无。</li>
</ul>
</li>
<li><strong>@PreDestroy</strong>：
<ul>
<li>位置：bean 的成员方法上。</li>
<li>说明：指定 bean 的销毁方法，在即将销毁之前执行。</li>
<li>属性：无。</li>
</ul>
</li>
<li><strong>@Scope</strong>：
<ul>
<li>位置：bean 的类声明上。</li>
<li>说明：指定 bean 的单例与多例、作用范围。</li>
<li>属性：</li>
<li>value（默认）：可取值如下：
<ul>
<li>singleton</li>
<li>prototype</li>
<li>request</li>
<li>session</li>
<li>globalsession</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-ioc配置类注解实现">8. IOC：配置类+注解实现</h2>
<h3 id="81-创建配置类--获取容器">8.1 创建配置类 &amp; 获取容器</h3>
<p>配置类就是通过一个 Java 类来替代 xml 配置文件。</p>
<ul>
<li>
<p><strong>创建配置类</strong>：</p>
<p>建议新建 config 包，并且配置类以 &quot;config&quot; 结尾。</p>
<p>使用如下注释，该类就成了配置类：</p>
<ul>
<li><strong>@Configuration</strong>：</li>
<li>位置：配置类的类声明</li>
<li>说明：指定当前类为 spring 容器配置类</li>
<li>属性：无</li>
</ul>
<pre><code class="language-java">@Configuration
public class BeansConfig{

}
</code></pre>
</li>
<li>
<p><strong>获取配置类容器对象</strong>：</p>
<p>获取配置类使用 ApplicationContext 的子类：<strong>AnnotationConfigApplicationContext</strong> 。</p>
<p>相对的，获取 xml 文件的容器对象使用的是 ClassPathXmlApplicationContext 。</p>
<pre><code class="language-java">public class Test{
  ApplicationContext factory = new AnnotationConfigApplicationContext(BeansConfig.class);
  public void test() {
      User user = (User)factory.getBean(&quot;id&quot;);
      ...
  }
}
</code></pre>
</li>
</ul>
<h3 id="82-包扫描">8.2 包扫描</h3>
<p>指定 spring 容器初始化时扫描的 java 包，扫描出其中通过注解配置的 bean。</p>
<p>效果同于 xml 中的：</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;io.github.photozynthesis.domain&quot; /&gt;
</code></pre>
<p>使用如下注解：</p>
<ul>
<li><strong>@ComponentScan</strong>：
<ul>
<li>位置：配置类的类声明。</li>
<li>说明：指定 spring 容器初始化时扫描的 java 包，扫描出其中通过注解配置的 bean。</li>
<li>属性：</li>
<li>value/basePackages（互相别名）：要扫描的完整包路径。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;io.github.photozynthesis.domain&quot;)
public class BeansConfig{
    
}
</code></pre>
<h3 id="83-任意方法定义-bean">8.3 任意方法定义 bean</h3>
<p>使用如下注解：</p>
<ul>
<li><strong>@Bean</strong>：
<ul>
<li>位置：配置类中的方法上。</li>
<li>说明：表明使用此方法创建一个对象（对象为返回值），并放入 spring 容器。</li>
<li>属性：value/name（互相别名了一波）：bean 的 id 。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">@Configuration
public class BeansConfig{
    @Bean(&quot;now&quot;)
    public Date getDate(){
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        try {
            date = sdf.parse(&quot;2018-08-08&quot;);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return date;
    }
}
</code></pre>
<h3 id="84-引入外部-properties-文件">8.4 引入外部 properties 文件</h3>
<p>引入外部 properties 文件后，可以通过表达式来动态获取 properties 中的内容，避免将代码写死。</p>
<p>使用如下注解来引入 properties 文件：</p>
<ul>
<li><strong>@PropertySource</strong>：
<ul>
<li>位置：类的方法声明上。</li>
<li>说明：引入 properties 文件。</li>
<li>属性：</li>
<li>value[]：指定 properties 文件位置。若文件在 classpath 中，还需要写上 classpath ，具体见下方示例。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p>jdbc.properties：</p>
<pre><code class="language-properties">jdbc.url = jdbc:mysql://localhost:3306/test?useSSL=false&amp;ServerTimezone=UTC
</code></pre>
<p>BeansConfig.java：</p>
<pre><code class="language-java">@Configuration
@PropertySource({&quot;classpath:jdbc.properties&quot;})
public class BeansConfig {
    @Value(&quot;${jdbc.url}&quot;)
    private String url;
    
    @Bean(&quot;url&quot;)
    public String getUrl() {
        return url;
    }
}
</code></pre>
<h3 id="85-引入其他配置类">8.5 引入其他配置类</h3>
<p>在一个配置类中引入其他配置类后，其他配置类就不用写<code>@Configuration</code>注解了（写也可以）。</p>
<p>利于配置类的管理。</p>
<ul>
<li><strong>@Import</strong>：
<ul>
<li>位置：配置类的类声明。</li>
<li>说明：引入其他配置类。</li>
<li>属性：value[]：指定导入的配置类的 class 字节码文件。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">@Configuration
@Import({UserBeansConfig.class, AccountBeansConfig.class})
public class CoreBeansConfig {
    
}

public class UserBeansConfig {
    @Bean(&quot;id&quot;)
    ...
}

public class AccountBeansConfig {
    @Bean(&quot;aid&quot;)
    ...
}
</code></pre>
<h2 id="9-aop概述">9. AOP：概述</h2>
<h3 id="91-aop-的概述">9.1 AOP 的概述</h3>
<ul>
<li>AOP（Aspect Oriented Programming），即面向切面编程。</li>
<li>利用 AOP 可以对业务逻辑中各个部分进行隔离，从而降低各模块间的耦合度。</li>
<li>AOP 可以将程序中重复的代码抽取出来。需要使用的时候，使用动态代理的技术，在不对代码进行修改的基础上对已有的方法进行增强。</li>
</ul>
<h3 id="92-aop-的优势">9.2 AOP 的优势</h3>
<ul>
<li>减少重复代码。</li>
<li>提高开发效率。</li>
<li>维护方便。</li>
</ul>
<h3 id="93-相关术语">9.3 相关术语</h3>
<ul>
<li>joinpoint：连接点，即被拦截到的点。在 Spring 中指方法。</li>
<li>pointcut：切入点，说明要对哪些连接点进行拦截。</li>
<li>advice：通知/增强，拦截到连接点后要做的事情就是连接点。通知有多种类型：
<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>异常通知</li>
<li>最终通知</li>
<li>环绕通知</li>
</ul>
</li>
<li>introduction：引介，是一种特殊的通知。在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</li>
<li>target：目标对象，代理的目标对象。</li>
<li>weaving：织入，是指把增强应用到目标对象来创建新的代理对象的过程。</li>
<li>proxy：代理，即一个类被织入增强后产生的结果代理类。</li>
<li>aspect：切面，即切入点和 通知/引介 的结合。</li>
</ul>
<h2 id="10-aopxml-实现">10. AOP：XML 实现</h2>
<h3 id="101-准备工作">10.1 准备工作</h3>
<ul>
<li>
<p><strong>导入包</strong></p>
<ul>
<li>aspectjweaver</li>
<li>aopalliance</li>
<li>spring-aop</li>
<li>spring-aspects</li>
<li><strong>IOC 的全部内容</strong></li>
</ul>
</li>
<li>
<p><strong>Spring 配置文件的约束文件</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;        				xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans               http://www.springframework.org/schema/beans/spring-beans.xsd 
           http://www.springframework.org/schema/aop               				http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="102-相关标签">10.2 相关标签</h3>
<ul>
<li><code>&lt;aop:config&gt;&lt;/aop:config&gt;</code>：
<ul>
<li>声明开始 aop，是个根标签。</li>
</ul>
</li>
<li><code>&lt;aop:aspect id=&quot;demoId&quot; ref=&quot;demo&quot;&gt;&lt;/aop:aspect&gt;</code>：
<ul>
<li>用于配置切面</li>
<li>属性：</li>
<li>id：切面的唯一标识</li>
<li>ref：通知类 bean 的 id</li>
</ul>
</li>
<li><code>&lt;aop:pointcut id=&quot;demoId&quot; expression=&quot;execution(public void ...)&quot; /&gt;</code>：
<ul>
<li>配置切入点表达式，指定对哪些类/哪些方法进行增强。</li>
<li>属性：</li>
<li>expression：切入点表达式，下文将详细描述</li>
<li>id：切入点表达式的唯一标识</li>
</ul>
</li>
<li><strong>通知配置相关标签</strong>：
<ul>
<li>一共有如下几种</li>
<li><code>&lt;aop:before&gt;</code>：<strong>前置通知</strong>，增强的方法将在<strong>切入点方法之前执行</strong></li>
<li><code>&lt;aop:after-returning&gt;</code>：<strong>后置通知</strong>，增强的方法将在<strong>切入点方法正常执行之后执行</strong></li>
<li><code>&lt;aop:after-throwing&gt;</code>：<strong>异常通知</strong>，增强的方法将<strong>在前置通知+切入点方法+后置通知中出现异常的时候执行</strong></li>
<li><code>&lt;aop:after&gt;</code>：<strong>最终通知</strong>，增强的方法<strong>在上面这些全执行完了才执行，出现异常不会触发异常通知</strong>。</li>
<li><strong>规则概述：上面的这些东西，简直就是在一个 <code>try...catch...finally...</code> 里</strong>。</li>
<li>通用属性：</li>
<li>method：指定通知类中的增强方法名。</li>
<li>pointcut-ref：指定配置好的 pointcut 的 id。</li>
<li>pointcut：定义自己的切入点表达式。</li>
</ul>
</li>
</ul>
<h3 id="103-切入点表达式">10.3 切入点表达式</h3>
<ul>
<li>
<p><strong>概述</strong>：</p>
<ul>
<li>切入点表达式<strong>用于说明要对哪些方法进行监听/增强</strong>。</li>
</ul>
</li>
<li>
<p><strong>规则（execution表达式）</strong>：</p>
<ul>
<li>
<p>以 <code>execution(...)</code> 为格式，以下为括号中的内容。</p>
</li>
<li>
<p>完整匹配（示例）：</p>
</li>
</ul>
<blockquote>
<p>权限修饰符 返回值类型 包.包.类名.方法名(包.包.类名, 包.包.类名)</p>
</blockquote>
<ul>
<li>
<p>权限修饰符 可以省略。</p>
</li>
<li>
<p>权限修饰符 可以用 <code>*</code> 通配。</p>
</li>
<li>
<p>包 可以用 <code>*</code> 通配，不过包的级数不能变。</p>
</li>
</ul>
<pre><code>execution(void io.*.*.service.MyService(java.lang.String, java.lang.Integer))
</code></pre>
<ul>
<li>
<p>包 可以用 <code>包..类名</code> 来表示当前包及所有子包。</p>
</li>
<li>
<p>类名 可以用 <code>*</code> 通配。</p>
</li>
<li>
<p>方法名 可以用 <code>*</code> 通配。</p>
</li>
<li>
<p>参数 可以用 <code>*</code> 通配，但是必须要有参数。</p>
</li>
<li>
<p>参数 可以用 <code>..</code> 来通配一切，有无参数，有多少个参数都行。</p>
</li>
<li>
<p>全通配示例：</p>
</li>
</ul>
<pre><code>execution(* *..*.*(..))
</code></pre>
</li>
</ul>
<h3 id="104-环绕通知">10.4 环绕通知</h3>
<ul>
<li>
<p><strong>概述</strong>：</p>
<ul>
<li>
<p>可以手动控制增强代码何时执行，一般独立使用（不同时使用其他四种通知）。</p>
</li>
<li>
<p>需要在通知类中写环绕通知对应方法，传递 spring 提供的 ProceedingJoinPoint 接口，并在方法中手动写入一个 <code>try...catch...finally...</code> ，以在随意位置进行想要的操作。</p>
</li>
<li>
<p>在环绕通知方法体中可以使用</p>
</li>
</ul>
<pre><code class="language-java">Object[] args = proceedingJoinPoint.getArgs();
</code></pre>
<p>来<strong>得到被增强方法的参数</strong>。</p>
<ul>
<li>在环绕通知方法体中可以使用</li>
</ul>
<pre><code class="language-java">Object result = proceedingJoinPoint.proceed(args);
</code></pre>
<p>来<strong>模拟被增强方法的执行</strong>。</p>
<ul>
<li>若有返回值，需要进行 return 返回。</li>
</ul>
</li>
<li>
<p><strong>属性</strong>：</p>
<p>tm 跟其他几个通知一样。</p>
</li>
</ul>
<h3 id="105-示例">10.5 示例</h3>
<ul>
<li>
<p><strong>一个后置通知的示例</strong>：</p>
<p>springConfig.xml</p>
<pre><code class="language-xml">...
&lt;beans ...&gt;

&lt;aop:config&gt;
  	&lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;myAdvice&quot;&gt;
      	&lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(void io.*.*.service.MyService.demoOperation())&quot; /&gt;
          &lt;aop:after-returning method=&quot;log&quot; pointcut-ref=&quot;pc&quot; /&gt;
      &lt;/aop:aspect&gt;
  &lt;/aop:config&gt;

  &lt;bean id=&quot;myAdvice&quot; class=&quot;io.github.pz.domain.MyAdvice&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<p>MyAdvice.java</p>
<pre><code class="language-java">@Component
public class MyAdvice {
  // 日志记录
  public void log() {
      System.out.println(&quot;日志记录&quot;);
  }
}
</code></pre>
<p>MyService.java</p>
<pre><code class="language-java">@Service
public class MyService {
  public void demoOperation() {
      System.out.println(&quot;操作中...&quot;);
  }
}
</code></pre>
</li>
<li>
<p><strong>一个环绕通知的示例</strong>：</p>
<p>springConfig.xml</p>
<blockquote>
<p>参考上文</p>
</blockquote>
<p>MyAdvice.java</p>
<pre><code class="language-java">@Component
public class MyAdvice {
  public Object myAdviceAround(ProceedingJoinPoint joinPoint) {
      try {
          someBefore();
          Object[] args = joinPoint.getArgs();
          Object result = joinPoint.proceed(args);
          someAfter_Returning();
      } catch (Throwable e) {
          someAfter_Throwing();
      } finally {
          someAfter();
      }
      return result;
  }

  // 这里还有一堆其他增强方法，懒得写了
  ...
}
</code></pre>
<p>MyService.java</p>
<blockquote>
<p>参考上文</p>
</blockquote>
</li>
</ul>
<h2 id="11-aop注解实现">11. AOP：注解实现</h2>
<h3 id="111-简要流程概述">11.1 简要流程概述</h3>
<ul>
<li>
<p>在 springConfig.xml 配置文件中<strong>指定要扫描的包</strong>（一般来说早就弄好了）。</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;io.github.pz&quot; /&gt;
</code></pre>
</li>
<li>
<p>在 springConfig.xml 配置文件中<strong>开启注解 AOP 支持</strong>。</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy /&gt;
</code></pre>
</li>
<li>
<p><strong>用注解配置通知类（应该做的），并同时使用 <code>@Aspect</code> 注解将其声明为切面</strong>。</p>
<pre><code class="language-java">@Component(&quot;myAdvice&quot;)
@Aspect
public class MyAdvice{
  ...
}
</code></pre>
</li>
<li>
<p><strong>在通知类的方法上使用注解将其设置为各种通知，可以直接传递切入点表达式</strong>。</p>
<pre><code class="language-java">@Component(&quot;myAdvice&quot;)
@Aspect
public class MyAdvice{
  @AfterReturning(&quot;execution(* *..*.*(..))&quot;)
  public void demoAfterRetruningMethod() {
      ...
  }
}
</code></pre>
<ul>
<li>@Before</li>
<li>@AfterReturning</li>
<li>@AfterThrowing</li>
<li>@After</li>
<li>@Around</li>
</ul>
</li>
</ul>
<h3 id="112-定义可重用的切入点表达式">11.2 定义可重用的切入点表达式</h3>
<p>随便弄个空的方法加上注解 <code>@Pointcut(表达式)</code> 就行了。该方法的**方法名()**就可以直接作为其他通知方法前的注解的参数。</p>
<pre><code class="language-java">@Component(&quot;myAdvice&quot;)
@Aspect
public class MyAdvice{
    @Pointcut(&quot;execution(* *..*.*(..))&quot;)
    public void pc() {}
    @AfterReturning(&quot;pc()&quot;)
    public void demoAfterRetruningMethod() {
        ...
    }
}
</code></pre>
<h3 id="113-使用配置类来开启注解-aop-支持">*11.3 使用配置类来开启注解 AOP 支持</h3>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages=&quot;io.github.photozynthesis&quot;)
@EnableAspectJAutoProxy
public class SpringConfiguration {
    
}
</code></pre>
<h2 id="12-事务控制xml-实现">12. 事务控制：XML 实现</h2>
<h3 id="120-spring-事务控制-api-概述">*12.0 Spring 事务控制 API 概述</h3>
<ul>
<li>PlatformTransactionManager：Spring 的事务管理器</li>
<li>TransactionDefinition：事务信息对象</li>
<li>TransactionStatus：事务状态对象</li>
</ul>
<h3 id="121-准备工作">12.1 准备工作</h3>
<ul>
<li>
<p><strong>导入包</strong></p>
<ul>
<li>spring-jdbc</li>
<li>spring-tx</li>
</ul>
</li>
<li>
<p><strong>约束</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<h3 id="122-配置步骤">12.2 配置步骤</h3>
<ul>
<li>
<p>在 springConfig.xml 中<strong>配置事务管理器</strong>（spring-jdbc 包提供）。需要一个 dataSource，自行配置连接池。</p>
<p>springConfig.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
&lt;!-- 自行配置连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
      &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
      &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true&quot; /&gt;
      &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
      &lt;property name=&quot;password&quot; value=&quot;demopasswd&quot; /&gt;
  &lt;/bean&gt;
</code></pre>
</li>
<li>
<p><strong>配置事务通知</strong>。</p>
<p>springConfig.xml</p>
<pre><code class="language-xml">&lt;!-- 需要指定之前配置的事务管理器的 id --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
&lt;!-- 置事务的属性 --&gt;
  &lt;tx:attributes&gt;
  	&lt;tx:method name=&quot;transfer*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRED&quot; /&gt;
      &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; propagation=&quot;SUPPORTS&quot; /&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p><code>&lt;tx:method&gt;</code> 的重要属性：</p>
<ul>
<li><strong>name</strong>：指示对应属性的事务将要应用到的方法，<code>*</code> 为通配符，例如 <code>find*</code> 表示所有以 find 开头的方法都要应用该标签表示的事务。</li>
<li><strong>read-only</strong>：是否只读事务。</li>
<li>false（默认）</li>
<li>true</li>
<li><strong>propagation</strong>：指定事务的传播行为。</li>
<li>REQUIRED：如果当前没有事务，就新建一个事务；如果已经存在一个事务中，加入到这个事务中。（默认）（建议）</li>
<li>SUPPORTS：支持当前事务，如果当前没有事务，就以<em>非事务方式执行</em>。</li>
<li>MANDATORY</li>
<li>REQUERS_NEW</li>
<li>NOT_SUPPORED</li>
<li>NEVER</li>
<li>NESTED</li>
<li>isolation：指定事务的隔离级别，默认为数据库的默认隔离级别。</li>
<li>ISOLATION_DEFAULT</li>
<li>ISOLATION_READ_UNCOMMITED</li>
<li>ISOLATION_READ_COMMITED</li>
<li>ISOLATION_REPEATABLE_READ</li>
<li>ISOLATION_SERIALIZABLE</li>
<li>timeout：指定超时时间，默认为 -1（永不超时），单位为 s。</li>
<li>rollback-for：指定产生什么异常时事务回滚。默认任何异常都回滚，若设置了则只针对设置的异常进行回滚。</li>
<li>no-roolback-for：指定产生什么异常时事务<strong>不</strong>回滚。默认任何异常<strong>都回滚</strong>，若设置了则只针对设置的异常之外的异常进行回滚。</li>
</ul>
</li>
<li>
<p><strong>配置切入点表达式</strong>，表示事务通知要应用于哪些包/类，注意不需具体到方法，因为方法已经在事务通知的配置中指定。</p>
<p>springConfig.xml</p>
<pre><code class="language-xml">&lt;aop:config&gt;
&lt;aop:pointcut id=&quot;demoPointcut&quot; expression=&quot;execution(* io.*.*.service.*.*(..))&quot; /&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
<li>
<p><strong>配置切入点表达式和事务通知的关系</strong>，在上面的标签中配置。</p>
<p>springConfig.xml</p>
<pre><code class="language-xml">&lt;aop:config&gt;
&lt;aop:pointcut id=&quot;demoPointcut&quot; expression=&quot;execution(* io.*.*.service.*.*(..))&quot; /&gt;
  &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;demoPointcut&quot; /&gt;
&lt;/aop:config&gt;
</code></pre>
<ul>
<li>advice-ref：事务通知的 id。</li>
<li>pointcut-ref：切入点表达式的 id。</li>
</ul>
</li>
</ul>
<h2 id="12-事务控制注解实现">12. 事务控制：注解实现</h2>
<p><strong>概述</strong>：</p>
<ul>
<li>
<p>导入包</p>
<p>略。</p>
</li>
<li>
<p>约束</p>
<p>略。</p>
</li>
<li>
<p>在 springConfig.xml 中<strong>配置事务管理器</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
&lt;!-- 自行配置连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
      &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
      &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true&quot; /&gt;
      &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
      &lt;property name=&quot;password&quot; value=&quot;demopasswd&quot; /&gt;
  &lt;/bean&gt;
</code></pre>
</li>
<li>
<p><strong>开启 spring 对注解事务的支持</strong>。</p>
<pre><code class="language-xml">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;
</code></pre>
</li>
<li>
<p>在 service 的 <strong>接口/类/方法</strong> 上使用 <code>@Transactional</code> 注解。</p>
<ul>
<li>
<p>属性（可参考 xml 配置部分）：</p>
</li>
<li>
<p>readOnly</p>
</li>
<li>propagation
<ul>
<li>Propagation.REQUIRED</li>
<li>Propagation.SUPPORTS</li>
<li>...</li>
</ul>
</li>
<li>
<p>...</p>
</li>
<li>
<p>关于注解位置的说明：</p>
</li>
<li>
<p>在接口上：该接口的所有实现类都有事务支持。</p>
</li>
<li>在类上：该类中所有方法都有事务支持。</li>
<li>在方法上：该方法有事务支持。</li>
<li>
<p>优先级：方法 &gt; 类 &gt; 接口。</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-java">@Service
@Transactional(readOnly=true, propagation=Propagation.SUPPORTS)
public class MyService {
    @Transactional(readOnly=false, propagation=Propagation.REQUIRED)
    public void transfer(...) {
        ...
    }
}
</code></pre>
</li>
</ul>
<h2 id="-组件junit-整合">#. 组件：Junit 整合</h2>
<ol>
<li>
<p>导入包</p>
<ul>
<li>spring-test</li>
</ul>
</li>
<li>
<p>在测试类上加上 <code>@RunWith(SpringJUnit4ClassRunner.class)</code></p>
</li>
<li>
<p>在测试类上加上 <code>@ContextConfiguration(locations={&quot;classpath:springConfig.xml&quot;})</code></p>
<p>locations 为 Spring 配置文件的位置。</p>
</li>
<li>
<p>已经可以随意进行测试，运行测试方法时会自动启动框架。</p>
<p>若要使用容器中的变量，像往常一样定义成员变量然后使用 <code>@AutoWired</code> 之类即可。</p>
</li>
</ol>
<h2 id="-组件spring-jdbc-template">#. 组件：Spring JDBC Template</h2>
<h3 id="1-概述">#.1 概述</h3>
<p>Spring框架对JDBC的简单封装，提供一个JdbcTemplate对象来简化JDBC开发。</p>
<h3 id="2-maven添加依赖">#.2 Maven添加依赖</h3>
<ol>
<li>在pom.xml中按照如下格式添加：</li>
</ol>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    ...
    &lt;dependencies&gt;
    	&lt;dependency&gt;
        	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol>
<li>Maven -&gt; Update Project，刷新项目以下载依赖，若下载失败，在<code>C:/user/&lt;username...&gt;/.m2/</code>下找到并删除下到一半的玩意，并重新刷新项目。</li>
<li>下载速度慢可以换Alibaba源或挂梯子。</li>
</ol>
<h3 id="3-使用步骤">#.3 使用步骤</h3>
<ol>
<li>
<p>导入jar包</p>
</li>
<li>
<p>根据DataSource创建JDBCTemplate对象</p>
<pre><code class="language-java">JdbcTemplate template = new JdbcTemplate(ds);
</code></pre>
</li>
<li>
<p>调用JdbcTemplate的方法来进行CUID操作，常用方法如下：</p>
<ul>
<li>
<p><strong>update</strong> (String sql, args...)，执行DML语句（增删改数据）</p>
<ul>
<li>若sql使用<code>?</code>作占位符，可使用args来传递参数，底层将使用PreparedStatement</li>
</ul>
</li>
<li>
<p><strong>queryForMap</strong> (String sql, args...)，查询并将结果封装为Map集合</p>
<ul>
<li>封装为Map时，查询的结果集只能有一条。</li>
<li>返回的Map表示这一个查询出来的条目，键为字段名，值为对应值</li>
<li>若sql使用<code>?</code>作占位符，可使用args来传递参数，底层将使用PreparedStatement</li>
</ul>
</li>
<li>
<p><strong>queryForList</strong> (String sql, args...)，查询并将结果封装为List集合</p>
<ul>
<li>将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。</li>
<li>返回的List集合中存储的是<code>org.springframework.util.LinkedCaseInsensitiveMap</code>对象</li>
<li>若sql使用<code>?</code>作占位符，可使用args来传递参数，底层将使用PreparedStatement</li>
</ul>
</li>
<li>
<p><strong>query</strong> (String sql, RowMapper)，查询并将结果封装为JavaBean对象</p>
<ul>
<li>
<p>使用RowMapper的实现类，可以实现数据到JavaBean的自动封装</p>
</li>
<li>
<p>使用<code>new BeanPropertyRowMapper&lt;Type...&gt; (&lt;Type.class...&gt;)</code>封装JavaBean</p>
</li>
<li>
<p>JavaBean的各字段名需要与查询结果的各字段名相同才会封装</p>
</li>
<li>
<p>使用举例：</p>
</li>
</ul>
<pre><code class="language-java">import ...;

public class JdbcTemplateTest {
   @Test
   public void test() {
       // Get DataSource and construct a JdbcTemplate instance
       C3p0JDBCUtils utils = new C3p0JDBCUtils();
	DataSource dataSource = utils.getDataSource();
       JdbcTemplate template = new JdbcTemplate(dataSource);

       // Construct a RowMapper instance using JavaBean's class
	RowMapper&lt;Emp&gt; rm = new BeanPropertyRowMapper&lt;&gt;(Emp.class);

       // Execute query and get a list of JavaBean instances
	List&lt;Emp&gt; list = template.query(&quot;select * from emp&quot;, rm);

       // output the list
	System.out.println(list);
   }
}

// JavaBean
class Emp {
   int id;
   String name;
   String job;
   String manager_id;

   ...
}
</code></pre>
</li>
<li>
<p><strong>queryForObject</strong> (String sql, class, args...)，查询并将结果封装为对象</p>
<ul>
<li>一般用于聚合函数查询，查询普通条目会报错</li>
<li>例如：查询<code>select count(*) from emp</code>，将返回long值</li>
</ul>
</li>
</ul>
</li>
</ol>


</body>
</html>
